# DB 성능 개선
일단 이 글은 DB 중에서도 MySQL을 기준으로 작성되어 있다. 이 글을 작성한 필자가 MySQL을 기준으로 설명하고 있기 때문이다.

## DB 성능 개선 방법
DB에 부하가 걸렸을 때 성능을 개선하는 방법은 다양하다 주로 아래와 같다.
* SQL 튜닝
* 캐싱 서버 활용(Redis 등)
* 레플리케이션 (Master/Slave)
* 샤딩
* 스케일업(CPU, Memory, SSD 등 하드웨어 업그레이드)

## SQL 튜닝을 먼저 고려해야 한다.
1. SQL 튜닝을 제외한 나머지 방법은 추가적인 시스템을 구축해야 한다. 따라서 금전적, 시간적 비용이 추가적으로 발생한다.
   조금 더 복잡해진 시스템 구조로 인해 관리 비용이 늘어난다. 그에 비해 SQL 튜닝은 기존의 시스템 변경없이 성능을 개선할 수 있다.
2. 근본적인 문제를 해결하는 방법이 SQL 튜닝일 가능성이 높다. SQL 자체가 비효율적으로 작성됐다면 아무리 시스템적으로 성능을 개선한다 하더라도 한계가 있다.
   하지만 SQL 튜닝을 통해 기본적으로 성능을 향상시킨다면 시스템적인 성능 개선이 필요없거나 훨씬 간단한 개선으로 큰 성능 개선 효과를 얻을 수 있다.
   
요약하자면, DB 성능 개선 방법들 중 가장 가성비가 좋고 기본적으로 깔고 가야할 것이 SQL 튜닝이다.

## DB 구조 파악 
어떤 부분에서 DB의 성능을 많이 잡아 먹는지, 어떤 요인이 주로 문제를 일으키는지 파악할 수 있어야 한다.
그 원인을 파악하기 위해서 DB의 구조를 알아야 한다. <br/>
아래는 MySQL 아키텍처를 간단히 표현한 것이고 쿼리를 실행하면 어떻게 수행되는지 알아본다. <br/>
![image](https://github.com/user-attachments/assets/d78591d7-6191-4c78-8155-4d310058001b) <br/>
1. 클라이언트가 DB에 SQL 요청을 보낸다.
2. MySQL 엔진에서 옵티마이저가 SQL 문을 분석한 뒤 빠르고 효율적으로 데이터를 가져올 수 있는 계획을 세운다.
   (어떤 순서로 테이블에 접근할 지, 인덱스를 사용할 지, 어떤 인덱스를 사용할 지 등을 결정)
3. 옵티마이저가 세운 계획을 바탕으로 스토리지 엔진에서 데이터를 가져온다.
4. MySQL 엔진에서 정렬, 필터링 등의 마지막 처리를 한 뒤에 클라이언트에게 SQL 결과를 응답한다.

쿼리를 실행하면 위의 순서대로 진행되며 DB 성능 문제의 대부분은 3번 과정, 스토리지 엔진으로부터 데이터를 가져올 때 발생한다.
데이터를 찾기가 어려워서 오래 걸리거나, 가져올 데이터가 너무 많아서 오래 걸린다. SQL 튜닝의 핵심은 스토리지 엔진으로부터
되도록이면 1) 데이터를 찾기 쉽게 바꾸고, 2) 적은 데이터를 가져오도록 바꾸는 것을 말한다.

그럼 이 2가지를 어떻게 해결할 수 있을까
여러가지 방법이 많지만 가장 활용되는 방법이 인덱스 활용이다. 인덱스가 어떤 개념이길래 위 2가지 문제를 해결할 수 있는 지 알아보자.
단순히 인덱스만 적용한다고 해서 무조건 해결되는 것이 아니다. 인덱스를 적절하게 활용해야만 DB 성능이 개선된다. 

## 인덱스
DB 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조, 구체적으로는 아래와 같다. <br/>
데이터를 빨리 찾기 위해 특정 컬럼을 기준으로 미리 정렬해놓은 표

### 예시를 통해 인덱스의 필요성 이해
<table>
   <tr>
      <th>id(PK)</th><th>이름</th><th>나이</th>
   </tr>
   <tr>
      <td>1</td><td>박미나</td><td>25</td>
   </tr>
   <tr>
      <td>2</td><td>김미현</td><td>23</td>
   </tr>
   <tr>
      <td>3</td><td>마석도</td><td>21</td>
   </tr>
   <tr>
      <td>4</td><td>이재현</td><td>23</td>
   </tr>
   <tr>
      <td>....</td><td>...</td><td>...</td>
   </tr>
   <tr>
      <td>10000</td><td>조민규</td><td>23</td>
   </tr>
</table>
위의 Users 테이블에서 1만 개의 데이터 중에서 나이가 23살인 사용자를 전부 직접 찾으려고 해보자. 나이가 뒤죽박죽 섞여 있기 때문에 모든 행을
일일이 검사해서 23살인 사용자를 뽑아내야 한다. 1만 개의 데이터를 일일이 다 확인해야 하므로 시간이 오래 걸린다. <br/><br/>

하지만 아래와 같이 나이 순으로 정렬된 표가 있다면? <br/>
![image](https://github.com/user-attachments/assets/8750f6bb-d7d5-4ffd-a223-534e9a3add82) <br/>
위의 표에서 ***23살로 시작하는 지점***과 ***24살로 시작하는 지점***만 찾은 뒤 그 사이에 있는 모든 값을 가져오면 된다. <br/>
미리 정렬을 해놓으니 모든 데이터를 일일히 다 확인할 필요가 없어서 훨씬 효율적으로 조회할 수 있다. <br/>

이러한 특징 때문에 데이터를 찾는 속도를 빠르게 만들기 위해서 인덱스를 많이 활용한다. <br/>
위에서 나이 칼럼을 기준으로 정렬된 표가 인덱스이다. 정확히 말하면 user 테이블의 나이 칼럼에 인덱스를 걸어주면 인덱스를 생성한다.
실제 DB에서는 인덱스를 생성한다고해서 실제로 정렬된 표를 확인할 수 없다. 시스템 내부적으로 생성될 뿐이다.

### 인덱스 실습
인덱스를 배웠고 이것을 실제로 적용해보고 성능이 향상되는 것을 확인하는 것이 중요하다.

```sql
-- 1. 테이블 생성
DROP TABLE IF EXISTS users;

CREATE TABLE users (
id INT AUTO_INCREMENT PRIMARY KEY,
name VARCHAR(100),
age INT
);

-- 2. 더미 생성
-- 기본 제약이 걸려있는 반복횟수를 뚫어준다. (더미 개수보다 많으면 된다.)
SET SESSION cte_max_recursion_depth = 1000000;

-- 더미 데이터 삽입
INSERT INTO users(name, age)
WITH RECURSIVE cte(n) AS
(
SELECT 1
UNION ALL
SELECT n+1 FROM cte WHERE n<1000000
)
SELECT
CONCAT('User', LPAD(n, 7, '0')), -- 'User' 다음에 7자리 숫자로 구성된 이름 생성
FLOOR(1 + RAND() * 1000) AS age -- 1부터 1000 사이의 랜덤 값으로 나이 생성
FROM cte;

-- 3. 인덱스 없을 때 성능 테스트
SELECT * FROM users
WHERE age=23;
-- 위의 쿼리를 실행하여 소요 시간과 행 개수를 체크한다.
-- 테스트는 한 번만 하는 것이 아니라 여러 번해서 샘플을 여러 개를 얻어서 평균값을 확인하고
-- 성능 향상이 몇 %가 향상되었는 지 정확한 수치를 체크해야 한다.

-- 4. 인덱스 생성 및 확인
CREATE INDEX idx_age ON users(age);
SHOW INDEX FROM users;

-- 5. 인덱스를 사용할 때 성능 테스트
-- 위의 SQL문으로 인덱스를 생성한 후 다시 테스트한다.
SELECT * FROM users
WHERE age=23;
```

### 기본으로 설정되는 인덱스(PK)
테이블에서 특정 데이터를 식별하기 위한 키를 보고 기본키(Primary Key, PK)라고 한다.
```sql
DROP TABLE IF EXISTS users; # 기존 테이블 삭제

-- 새 테이블 생성
CREATE TABLE users(
id INT PRIMARY KEY,
name VARCHAR(100)
);

-- 테스트 케이스 입력
INSERT INTO users(id, name) VALUES
(1, 'a'),
(3, 'b'),
(5, 'c'),
(7, 'd');

-- 테스트
UPDATE users
SET id=2
WHERE id=7;

-- 인덱스 확인
SHOW INDEX FROM users;
```


출처 : <br/>
https://www.youtube.com/watch?v=vbatA68GL1I&list=PLtUgHNmvcs6rJBDOBnkDlmMFkLf-4XVl3&index=4 <br/>
<hr/><br/><br/>








