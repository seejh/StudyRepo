여기서는 개념적인 내용만 다룬다. 디테일한 내용에 대해서는 따로 추가적인 공부가 필요하다. <br/>

# 파티셔닝, 샤딩, 리플리케이션
테이블을 나누거나 관리하는 방법은 여러 방법이 있다.<br/>
그 중에서도 비슷하면서도 다른 세 가지 개념을 알아보자 <br/>

# Partitioning
db 테이블을 더 작은 테이블로 나누는 것으로 **Vertical 방식**과 **Horizontal 방식**이 있다. <br/>

### 1. Vertical Partitioning 방식
**Column**을 기준으로 테이블을 나누는 방식.<br/>
정규화도 vertical 방식이다. <br/>
<img width="400" height="300" alt="image" src="https://github.com/user-attachments/assets/f919fc94-b221-4f2a-8201-a4449d1c8e53" /><br/>
위의 그림을 보면 하나의 테이블을 칼럼을 기준으로 나누고 있다. <br/>

#### 정규화란?
* db에 중복된 데이터가 저장되는 것을 방지하기 위한 목적으로 사용
* insert, update, delete를 할 때 문제가 생기는 것을 방지하기 위한 목적으로 사용

#### vertical 방식의 필요성
아래는 게시판에 기재되는 게시물(Article)에 대한 테이블과 해당 테이블을 실사용하는 모습이다. <br/>
<img width="500" height="200" alt="image" src="https://github.com/user-attachments/assets/a8ba3421-a63f-4571-9212-48a3fd3a114f" /><br/>
<img width="400" height="550" alt="image" src="https://github.com/user-attachments/assets/38094444-3683-466a-86bd-88107ca1c878" /><br/>
게시판에서 위와 같은 정보들을 가지고 오는 쿼리문은 아래와 같을 것이다. <br/>
```sql
SELECT id, title... comment_cnt
FROM article
WHERE ...
```
일단 위의 쿼리문이 실제로 어떻게 동작하는지 알아보자
* HDD, SSD에 저장되어 있는 데이터를 일단 행을 기준으로 싹 다(id ~ content) 메모리로 읽어온다.
* 그 후 명시한 조건에 따라 필터링을 거친다.

Content는 게시물의 내용에 대한 항목으로 위의 상황에서는 필요하지 않고 또한 데이터의 사이즈가 매우 클 것이라고 예상이 된다. 그래서 쿼리에서도 Content는 포함시키지 않고 SELECT로 조회를 한다. 그러나 위의 실제 동작 과정을 보면 Content의 내용까지 들고 오고 그 후에 필터링을
진행한다는 것으로 이처럼 필요 없는 데이터를 가져오는데 대한 I/O에 대한 부담이 생긴다는 것이다.
이러한 경우에 **Vertical Partitioning**을 통해 해결할 수 있다. <br/>

아래는 Vertical Partitioning을 한 모습이다.  <br/>
<img width="600" height="250" alt="image" src="https://github.com/user-attachments/assets/f6b02158-5bfd-4589-9057-b62694fac040" /><br/>
이미 정규화가 되어 있는 테이블이라도 퍼포먼스(성능)를 위해서 파티셔닝을 진행할 수 있고 그 외에도 민감한 정보를 분리하거나 자주 사용되는
속성(칼럼)들을 파티셔닝할 수 있다. 파티셔닝 후 원래의 전체 데이터가 필요한 경우는 그 때에는 조인을 통해 전체 데이터를 가져오는 식으로 한다. <br/>

### 2. Horizontal Partitioning 방식
**Row**를 기준으로 테이블을 나누는 방식<br/>
<img width="500" height="200" alt="image" src="https://github.com/user-attachments/assets/76d94668-74b2-4d01-a4a7-0ed6094de216" /><br/>
Row를 기준으로 나누기에 스키마는 유지된다. <br/>

#### Horizontal 방식의 필요성
테이블의 크기가 커질수록 인덱스의 크기도 커진다. 또 인덱스의 크기가 커질수록 읽기/쓰기가 있을 때 마다 인덱스에서 처리되는 시간도 조금씩
늘어난다. 결국은 "데이터 증가 -> 인덱스 증가 -> 쿼리 성능 하락" 이라는 것이고 데이터가 늘어날수록 성능이 떨어진다는 것이 처음에는 체감이
안 될 수 있지만 그 구조상 "언젠가는 성능 저하가 체감이 되는 순간까지 올 수 있다"라는 위험부담으로 다가온다. 이를 해결할 수 있는 방법이
Horizontal Partitioning이다. 해시 기반(Hash-Based), 범위 기반(Range-Based) 등 여러가지 방법이 있지만 가장 많이 사용하는 해시 기반으로
알아본다. <br/>

<img width="700" height="300" alt="image" src="https://github.com/user-attachments/assets/375ea8e9-c984-4df3-8b4b-259403b8d355" /><br/>
유튜브에서 구독자(user_id)가 어떤 채널(channel_id)을 구독하고 있는지에 대한 테이블이고 왼쪽이 원본 테이블, 우측이 원본 테이블에 데이터가
많이 쌓여서 해시 기반 수평 파티셔닝을 진행한 모습이다. 하나의 테이블에 저장되어 있는 데이터들을 파티션을 나눠서 저장하는데 파티션 키를 정하고
해당 파티션 키를 해시 함수를 돌렸을 때 나온 값에 해당하는 파티션에 다가 저장하는 방식이다. 여기서는 user_id를 파티션 키로 지정하였다.<br/>

#### 유의 사항에 대해서 알아보자
* dingyo가 구독한 채널들 정보를 모두 조회하고 싶다면?<br/>
dingyo라는 유저의 구분이 user_id로 되고 파티션 키가 user_id이므로 한 파티션에서 모든 조회를 할 수 있다. <br/>

*id가 1인 채널을 구독한 사용자의 id를 모두 조회하고 싶다면?<br/>
모든 테이블을 다 조회하여야 한다.<br/>

고로 가장 많이 사용될 패턴에 따라 파티션 키를 정하는 것이 중요하다.<br/>

* 데이터 균등 분배<br/>
데이터가 균등하게 분배될 수 있도록 hash function을 잘 정의하는 것이 중요하다.

* 한 번 설정하면 유지보수가 힘들다 <br/>
해시 기반 방식의 내용. 해시 기반으로 파티셔닝을 나누게 되면 이후 유지보수(파티션 추가 또는 제거)를 하기가 까다롭기에
한 번 설정할 때 잘 고민해서 해야 한다.<br/>

#### 샤딩
Horizontal Partitioning과 뭔가 다른 것이 아니라 Horizontal Partitioning을 사용하여 분리된 파티션들을 한 DB 머신이 아니라 독립된 각각의
DB 머신에 저장하는 것. Horizontal 방식으로 분리를 했더라도 동일 머신내에서 분리되어 있으면 해당 DB 머신의 CPU와 메모리의 한정된 자원을
공유해서 사용한다는 것으로 DB 머신을 분리해서 사용하면 부하 분산의 효과를 가진다. 데이터가 많이 쌓이는 테이블, 트래픽이 많이 몰리는 테이블에는
샤딩을 써서 각 파티션 마다 독립된 DB 머신을 할당하고 트래픽을 분산시켜서 부하를 줄인다. <br/>

샤딩에서는 파티션 키를 샤드키, 파티션을 샤드(Shard, 조각)라고 부른다. <br/>

#### 리플리케이션
DB 서버가 문제가 생겼을 때 서비스의 문제로 이어진다. 리플리케이션은 같은 내용을 담는 DB 서버를 여러 개 두고 하나의 DB 서버가 다운되면 
다른 DB 서버로 대체한다는 것으로 주로 주 DB 서버에 Write 되는 내용을 다른 부 DB 서버들에 복사시키는 식으로 사용하고 
복사에는 여러 가지 방법이 사용될 수 있는데 여기서는 다루지 않는다. 또한 지금 말한 것은 active-standby 전략이고 active-active 방식도 있다.<br/>
<table>
  <tr>
    <td>주 DB 서버</td>
    <td>master, primary, leader</td>
  </tr>
  <tr>
    <td>부 DB 서버</td>
    <td>slave, secondary, replica</td>
  </tr>
</table>
위는 주 DB와 부 DB를 부르는 호칭에 대한 내용이며 각 순서로 매칭되어 사용된다. slave는 부정적인 면이 있어서 잘 사용하지 않으려
한다고 한다. <br/>

#### FailOver (페일 오버)
주 DB 서버가 다운됬을 때 부 DB 서버를 메인으로 올려서 사용하는 것.
장애 상황이 발생했을 때 계속해서 서비스가 유지될 수 있도록 하는 구성 또는 특성을 HA(High-Availability, 고가용성)라고 한다.
레플리케이션을 구성하면 HA 특성을 보장할 수 있다.

#### 부하 분산
레플리케이션을 구성했을 때 얻을 수 있는 추가적인 장점은 주 db 서버로 가는 read 트래픽의 일부를 분산시켜 줄 수 있다.


출처 : <br/>
https://www.youtube.com/watch?v=P7LqaEO-nGU <br/>
<hr/><br/><br/>
