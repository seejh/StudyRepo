Transactioin Isolation Level(트랜잭션 격리 수준)

사전에 알아야할 내용<br/>

트랜잭션<br/>
트랜잭션은 하나의 논리적 작업 단위로 수행되는 일련의 작업이다. ACID(원자성, 일관성, 격리성, 영속성)을 만족해야 한다.
기본적으로 트랜잭션은 커넥션 수준에서 관리된다.

Lock<br/>
다른 트랜잭션에 의한 충돌이나 불완전한 접근을 방지하면서 데이터를 보호하기 위해 트랜잭션이 소유하는 관리 리소스를 말한다.

Exclusive Lock(배타 잠금, XLock)<br/>
다른 트랜잭션이 write할 수 없고, read의 경우는 NOLOCK으로 힌트를 주거나 Read Uncommitted 격리 수준에서만 가능

Shared Lock(공유 잠금, SLock)<br/>
다른 트랜잭션이 write할 수 없고, 
비관적 동시성 제어 하에서 리소스를 읽을 수 있다. 공유 잠금이 리소스에 존재하는 동안 다른 트랜잭션은 데이터를 write할 수 없다.

<hr/>
동시성 부작용<br/><br/>

Dirty Read(커밋되지 않은 종속성)<br/>
커밋되지 않은 데이터를 읽는 경우. 다른 트랜잭션에서 작업이 확정나지 않은 데이터를 읽는 것으로 문제가 될 수 있는 상황.

Non-Repeatable Read(일관성없는 분석)<br/>
트랜잭션 내에서 데이터 조회 시 다른 트랜잭션에 의해 레코드가 변하는 경우

Phantom Read(가상 읽기)<br/>
트랜잭션 내에서 데이터 조회 시 다른 트랜잭션에 의해 레코드가 생기거나 사라지는 경우

<hr/>

트랜잭션 격리 수준<br/>
레벨이 낮을수록 격리 수준이 낮아지는 것으로 성능은 더 향상되지만 발생할 수 있는 부작용의 가짓수는 올라간다.<br/>


<table>
<th>격리 레벨</th><th>Dirty Read</th><th>Non-Repeatable Read</th><th>Phantom Read</th>
<tr>
  <td>Read Uncommitted(Level 0)</td><td>발생</td><td>발생</td><td>발생</td>
</tr>
<tr>
  <td>Read Committed(Level 1)</td><td>발생X</td><td>발생</td><td>발생</td>
</tr>
<tr>
  <td>Repeatable Read(Level 2)</td><td>발생X</td><td>발생X</td><td>발생</td>
</tr>
<tr>
  <td>Serializable(Level 3)</td><td>발생X</td><td>발생X</td><td>발생X</td>
</tr>
</table>

1 - Read Uncommitted<br/>
한 트랜잭션에서 데이터를 읽을 시 타 트랜잭션에서 커밋되지 않은 내용도 조회한다.<br/>
<br/>Dirty Read가 발생할 수 있는 환경

2 - Read Committed<br/>
MSSQL DB에서 기본적으로 채택하는 격리 수준.
한 트랜잭션에서 타 트랜잭션이 완료(커밋)될 때까지 기다리지 않고 조회할 수 있다.
(타 트랜잭션의 현재 변경하고 있는 커밋되지 않은 정보를 조회하는 것이 아니라, 작업을 하기 전, 아예 초기의 데이터가 저장되어 있는
UNDO 영역의 레코드 값을 조회)
DB 엔진은 트랜잭션이 끝날 때까지 쓰기 잠금을 유지하지만 읽기 작업이 수행되는 즉시 읽기 잠금이 해제된다.<br/>
<br/>Dirty Read, Non-Repeatable Read가 발생할 수 있는 환경

3 - Repeatable Read<br/>


<br/>Dirty Read, Non-Repeatable Read, Phantom Read가 발생할 수 있는 환경

4 - Serializable<br/>
트랜잭션 간 완전히 격리되는 수준.


<hr/>
추가 내용(확인 필요)<br/>

MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)<br/>
잠금을 사용하지 않는 일관성 읽기 제공.
DBMS에서는 쓰기 세션이 읽기 세션을 블로킹하지 않고, 읽기 세션이 쓰기 세션을 블로킹하지 않게 서로 다른 세션이 동일한 데이터에 접근했을 때 각 세션마다 스냅샷 이미지를 보장해주는 메커니즘.

UNDO<br/>

REDO<br/>
트랜잭션이 성공적으로 커밋된 후에도 DB가 갑작스럽게 중단되었을 때 커밋된 DB의 변경 사항을 복원하는데 사용


