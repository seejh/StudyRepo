게임 서버에서 DB를 비동기로 사용할 때 자주 맞닥뜨리는 문제로 정합성과 동기화 문제의 대표적인 예라고 한다.<br/>

게임 서버에서 DB 하나를 비동기로 사용하고 있음. 아이템 변경(예. 유저 간 거래)같은 건은 변경이 있으면 DB에 적용 후에 게임 로직을 진행하기로 함.
그렇다면 아래와 같이 된다.
```
게임 로직 아이템 변경 요청(아이템 삭제) -> DB 비동기 요청 ->
게임 로직에서 응답 받고 작업
```

문제는 아래와 같은 상황이 발생할 수 있다.
```
게임 로직 아이템 변경 요청(아이템 삭제) -> DB 비동기 요청 -> 게임 로직 아이템 변경 요청(아이템 장착)
-> DB 비동기 요청 -> 게임 로직에서 응답 받고 작업
```
요청 순서대로 작업이 되지 않을 수가 있고 이렇게 되면 삭제된 아이템을 장착하는 상황이 됨. <br/>

# 핵심 문제
비동기 응답 순서 역전 + 상태 불일치<br/>
비동기 요청은 서버에서 논리적으로 순서를 맞춰도, DB 응답이 오는 순서가 보장되지 않기 떄문에, 게임 로직이 엉킬 수 있음.

# 해결 방안들
## 1. 요청 큐 + 순차 처리 방식
아이템에 대해 처리 중인 DB 작업이 완료될 때까지 다음 요청을 보류하거나 큐에 저장.<br/>
"게임 로직 아이템 변경 요청 -> 큐에 적재 -> DB에서 순서대로 처리" 요런 방식.<br/>

```c++
// 다만 이런 식의 큐는 플레이어 단위 혹은 아이템 단위로 관리해야 충돌이 안남.
struct ItemOp { std::function<void()> task; };

queue<ItemOp> itemOpQueue;
bool itemBusy = false;

// 게임 로직
void OnItemRequest(ItemOp newOp) {
  if (itemBusy)
    itemOpQueue.push(newOp);
  else {
    itemBusy = true;
    newOp.task(); // 비동기 DB 작업
  }
}
// DB
void OnDBResponse() {
  // DB 작업 완료됨
  itemBusy = false;

  // 다음 작업 수행
  if (!itemOpQueue.empty()) {
    ItemOp nextOp = itemOpQueue.front();
    itemOpQueue.pop();
    itemBusy = true;
    nextOp.task();
  }
}
```

## 2. 상태 플래그 잠금
아이템이나 유저에게 "itemState = BUSY" 같은 상태를 부여.<br/>
해당 상태일 때는 추가 변경 요청을 거부하거나 임시로 큐에 저장.<br/>

간단하고 방어적인 방법이지만 사용자 경험이 다소 제한적일 수 있다.
```
로직에서 아이템 변경 요청 받음 & 아이템에 BUSY 상태 걸음 -> DB 작업 요청 ->
로직에서 같은 아이템에 대해 다른 변경 요청을 받음 -> BUSY라 작업할 수 없다고 알림
```

## 3. 로컬 캐시 먼저 반영, 나중에 롤백 (낙관적 처리 + 실패 시 롤백)
요청 들어오면 서버 메모리 선 변경 (삭제, 장착) 후 비동기 DB 요청.<br/>
실패 시 롤백 처리(아이템 부활 등).<br/>

이 방법은 반응은 빠르지만 롤백 구현이 매우 까다롭고 위험성이 크다.<br/>
특히 아이템 중복, 유실, 거래 오류 등이 발생할 수 있다.<br/>

# 결론
"DB 응답 후 게임 로직 처리"는 정합성 측면에서 매우 타당하다.<br/>
"비동기 요청이 중첩될 수 있는 구조"에서는 요청 순서대로 처리 안 될 수 있고 이것이 문제가 된다.<br/>

위에서 3번 방식은 가장 성능을 중시한 방법이지만 리스크가 크고, 2번 방식의 경우 가장 안전하지만 유저 경험(성능)이 가장 별로일 것이므로
2번 방식에서 요청할 때부터 거절하는 것이 아니라 요청은 받고 순서대로 처리하게끔 만드는 1번 방식으로 하는 것이 현재로서는 가장
합리적인 방법인 것 같다.


