*리플리케이션
여러 db를 권한에 따라 수직적으로 연결, 마스터는 쓰기 작업만 하고 슬레이브는 읽기 작업만 처리한다.
마스터와 슬레이브 간 데이터 무결성 검사를 하지 않는 비동기 방식으로 노드들 간의 데이터를 동기화한다.

장점
읽기 성능을 높일 수 있고 지연 시간이 없다
단점
노드들 간의 데이터 동기화가 보장되지 않아 일관성 있는 데이터를 얻지 못할 수 있다.
마스터가 다운되면 복구 및 대처가 까다롭다

*클러스터링
여러 DB를 수평적인 구조로 구축하는 방식
failover 시스템을 구축하기 위해 사용한다.
db들 간 무결성 검사를 하는 동기 방식으로 데이터를 동기화 한다.
항상 가용할 수 있게 하는 active-active 방식과 일부 클러스터는 대기 상태로 구성하는 active-standby로 
나뉜다.

장점
항상 일관성 있는 데이터를 얻을 수 있고 노드 하나가 다운되더라도 시스템을 장애 없이 운영 가능
단점
노드들 간 데이터 동기화 시간이 필요해 리플리케이션에 비해 쓰기 성능이 떨어진다.
데이터 동기화에 의해 스케일링에 한계가 있다.

* failover (페일 오버) ?
장애 대비 기능. 장애가 발생 시 예비 시스템으로 자동 전환하는 기능이다. 추가적인 자원을 필요로 한다.
이처럼 같은 시스템을 2개 준비하는 것을 이중화라고 한다.

binlog
서버 내 발생되는 모든 변경 내역이 기록되는 파일
PIT (시점 복구)
안 쓰면 활성화할 필요 없다. IO 부담을 가중시키기 때문

GTID
데이터베이스로 커밋되는 각 트랜잭션과 함께 생성되고 트랜잭션에 연결되는 고유한 식별자이다.
GTID를 사용하면 각 트랜잭션들은 고유한 전역 식별자를 가진다. 완전한 트랜잭션 기반이다.
row-based replication의 성능이 더 좋다.

주석 : 
위에서 리플리케이션과 클러스터링이라는 기술을 소개하고 있고 리플리케이션은 성능, 클러스터링은
안정성으로 각각 용도가 정해져 있다. 내가 실사용하기에, 유저가 몬스터를 처치하고 아이템을 
획득하는 등의 로직을 처리하기에는 안정성이 없으면 위험해서 사용할 수 없다. 따라서 사용하지 않기로 결정
----------------------------------------------------------------------------------------------------------
chatgpt에게 묻고 얻은 답변에 대한 정리

1) 보류해도 되는 데이터, 2) 바로 저장할 데이터를 구분한다.

1) 보류해도 되는 데이터 처리
서버 인메모리에서 보관, 사용. 일정한 텀을 주기로 백엔드 db에 저장.
모든 데이터를 저장하겠다고 db에 매번 접근하는 것은 성능적으로 좋지 않다.
그러한 관점에서 봤을 때 db에 접근하는 횟수를 줄여야할 필요가 있다. 최대한 보류해도 되는 데이터는
모아서 처리함으로써 db 접근 횟수를 줄임으로서 db 성능을 향상시킨다.

이 방법으로 처리하는 항목 : 위치, hp 등 실시간 상태

구체적인 구조 설명
1-1) 메모리 상태 관리
플레이어 위치, 체력, 버프 상태, 스킬 사용 등은 전부 서버 인메모리에서 유지
C++ 객체로 관리(Player, Inventory, Monster 등)
상태 변경은 즉시 객체에 반영 (빠름, 응답성 우수)

1-2) 변경 사항을 모아서 기록 (Dirty Flag or Queue 방식)
변경이 발생한 객체에 dirty 플래그 설정
또는 변경 로그를 큐(리스트, 구조체 등)에 저장

1-3) 주기적/이벤트 기반 동기화
예 : 10초마다 한 번 모든 dirty 데이터를 db에 저장 또는 로그아웃, 맵 이동 등 시점에만 동기화
백그라운드 스레드 또는 별도 저장 스레드에서 처리
--cpp
for (auto& player : players) {
	if (player.is_dirty()) {
		save_to_db(player); // 비동기일수록 좋다.
		player.clear_dirty();
	}
}
--

1-4) 복구/백업 용도로만 db 사용
db는 궁극적인 "진실의 원천"이지만, 실시간 로직에는 개입하지 않음
서버 재시작 시 db에서 복원해 메모리 객체 초기화

주의할 점
멀티 서버 환경에서의 충돌
플레이어가 여러 서버에 접속 가능한 구조라면 인메모리에 동기화에 어려움이 있음
분산 락, 중앙 세션 관리, redis 기반 동기화 고려

2) 바로 저장할 데이터
"중요 이벤트만 예외적으로 즉시 동기 저장"하는 방식이 실무에서 가장 많이 사용된다.
db 반영 -> 메모리 반영 -> 클라이언트 알림











