# 질문1
c++ iocp를 사용하면 시스템 콜이 발생하나?

# 답변1
발생한다. <br/>
CreateIoCompletionPort(), WSARecv(), WSASend() 등은 커널에 요청을 보내기 위해 내부적으로 시스템 콜을 수행한다.

## 예제 : WSARecv()
커널에 "이 소켓에 데이터가 도착하면 나중에 알려줘"라는 요청을 보내는 것으로 이 요청은 반드시 커널 모드로 전환(시스템 콜)되어야 하므로 시스템 콜이 발생한다.
이 요청이 완료되면 커널은 IOCP 큐에 완료 알림을 전달한다.

## 결론
IOCP는 유저 모드에서 비동기 I/O 요청하고 커널 모드에서 완료 이벤트를 처리하도록 설계된 모델이다. <br/>

이때 비동기 요청을 등록하고 완료 이벤트를 기다리는 동작은 모두 시스템 콜을 통해 커널과 통신하는 과정이 필요하다.

# 질문2
시스템 콜이 부하가 상당하다고 하는데 이유가 뭘까?

# 답변2
시스템 콜이 비용이 높은 연산이라고 하는 이유는 주로 "유저 모드 <-> 커널 모드 간의 전환" 때문이며 이 전환은 cpu, 메모리, 보안 모델 등 여러 레벨에서 성능 비용을 수반한다.


# 질문3
컨텍스트 스위치는 시스템 콜을 쓰든 안 쓰든 발생하는 것 아닌가? "그러면 상관없는 것 아닌가?"라는 물음이 생기는데 저 말이 시스템 콜이 컨텍스트 스위치를 야기한다는 것인가?

# 답변3
시스템 콜이 항상 컨텍스트 스위치를 일으키는 것은 아니지만, 컨텍스트 스위치를 야기할 수 있는 주요 원인 중 하나이다.

## 컨텍스트 스위치?
cpu가 한 프로세스/스레드에서 다른 프로세스/스레드로 작업을 넘기는 것.

* 발생 원인

스케줄러에 의한 시간 할당 종료(타이머 인터럽트)<br/>
I/O 대기 (예: 블로킹 read)<br/>
동기화 객체 대기(mutex, semaphore 등)<br/>
시스템 콜 중 커널이 판단하여 대기 블록<br/>

## 시스템 콜과 컨텍스트 스위치의 관계
시스템 콜에는 2가지 유형이 있다.(블로킹, 논블로킹)
<table>
  <tr>
    <td>시스템 콜 종류</td><td>예시</td><td>컨텍스트 스위치 발생 가능성</td>
  </tr>
  <tr>
    <td>논블로킹</td>
    <td>getpid(), time()</td>
    <td>없음 (거의 즉시 반환)</td>
  </tr>
  <tr>
    <td>블로킹</td>
    <td>read(), recv(), select()</td>
    <td>있음 (I/O 대기 시 스레드 sleep)</td>
  </tr>
</table>
정리하자면 "시스템 콜 자체가 컨텍스트 스위치를 유발하는 것은 아니다." 그 시스템 콜이 "블로킹 상태에 빠질 경우" 커널이 스레드를 다른 작업으로
넘기기 위해 컨텍스트 스위치를 발생시킴.

## 예시 : recv() 호출<br/>
데이터가 없다면? -> 커널은 해당 스레드를 sleep 시킴 -> cpu는 다른 작업을 하도록 컨텍스트 스위치 발생
