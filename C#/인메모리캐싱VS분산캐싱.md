# ASP.NET Core 에서 인메모리 캐싱과 분산 캐싱의 차이점
인메모리 캐싱(In-Memory Caching) 및 분산 캐싱(Distributed Caching)은 ASP.NET Core에서 사용되는 두 가지 일반적인 캐싱 전략으로 <br/>
데이터베이스와 같이 느린 데이터 소스에서 반복적으로 가져오는 대신 자주 액세스하는 데이터를 캐시에 저장하여 애플리케이션 성능 및 확장성을 향상시킨다.<br/>
다음은 이러한 두 가지 유형의 캐싱 간의 차이점에 대한 분석이다. <br/>
쉽게 말해 메모리DB를 사용하는데 웹앱의 메모리를 사용하는 것과 따로 메모리DB를 사용하는 것인듯 하다 <br/>
그리고 DB로서의 관점이 아니라 주 DB가 있는 환경에서 메모리 캐싱을 담당하는 메모리DB의 관점에서의 내용인듯 하다.<br/>
# ASP.NET Core에서의 인메모리 캐싱
인메모리 캐싱은 앱이 실행중인 웹 서버의 메모리에 캐시된 데이터를 저장하는 것을 말한다. <br/>
이러한 캐싱은 외부 호출 없이 앱에서 직접 액세스할 수 있으므로 매우 빠르다. <br/>

![image](https://github.com/user-attachments/assets/e0ca385c-b059-4c2e-82e0-757be65da57c)
# 설정 및 구성
## 캐시 공급자
분산 캐싱 솔루션은 없지만 ASP.NET Core에는 인메모리 캐시 공급자가 내장되어 있다.
## 캐시 구성
앱의 프로세스 내에서 동작함으로 최소한의 구성만 해주면 된다. <br/>
Program.cs 의 구성에서 서비스 컬렉션에 추가해야 한다. <br/>
IMemoryCache를 활용한다. <br/>

## 인메모리 캐싱 장점
### 속도 
데이터가 애플리케이션의 메모리에 직접 저장되기 때문에 액세스 시간이 매우 빠르다. <br/>
### 성능 향상 
특히 자주 액세스하는 데이터의 경우 느린 데이터베이스에서 데이터를 검색할 필요성을 줄인다. <br/>
### 편의성 
ASP.NET Core 프레임워크내에 쉽게 통합되고 추가 인프라가 필요없다. <br/>

## 인메모리 캐싱 단점
### 확장성
데이터는 앱이 실행 중인 서버의 메모리에 저장되기 때문에 분산 캐싱과 달리 클라우드 환경에서 자동으로 확장되지 않는다. <br/>
### 데이터 변동성
앱이 다시 시작되거나 충돌하는 경우 메모리 내 캐시의 데이터가 손실될 수 있다. <br/>
이러한 일은 분산 캐싱 솔루션에서는 발생하지 않는다. <br/>
## 인메모리 캐싱 사용 사례
인메모리 캐싱은 일반적으로 캐시 무효화가 문제가 되지 않고, 설정 편의성이 우선 순위인 소규모 또는 단일 서버 프로그램에 사용된다. <br/>
단일 서버 또는 각 서버가 자체 격리된 캐시를 안전하게 가질 수 있는 인스턴스에 배포된 앱 <br/>
대기 시간이 중요한 요소이고 캐시된 데이터에 최대한 빨리 액세스해야 하는 상황<br/>
작업 부하와 데이터 크기를 예측할 수 있는 환경에서는 서버 메모리가 오버로드될 위험없이 효율적인 메모리 관리가 가능 <br/>

## 사용
### 캐시 액세스
생성자 주입을 통해 컨트롤러 또는 서비스에서 캐시로 액세스 할 수 있다. <br/>
ASP.NET Core의 DI 컨테이너는 캐시된 항목을 설정하고 검색할 수 있는 IMemoryCache 인스턴스를 제공한다. <br/>
### 데이터 저장
Set, CreateEntry 또는 확장 메서드인 GetOrCreate와 같은 메서드를 사용한다. <br/>
데이터와 키를 제공하고 필요에 따라 만료 시간과 같은 캐시 옵션을 설정할 수 있다. <br/>
### 데이터 검색
Get 메서드로 키를 제공하여 데이터를 검색할 수 있다. 키가 있다면 캐시된 데이터를 가져오며 없으면 null을 넘긴다. <br/>
GetOrCreate 메서드는 찾는 데이터가 없으면 만드는 기능이다. <br/>
### 옵션
#### Absolute Expiration(절대 만료)
사용에 관계없이 캐시 항목이 만료되는 시간을 설정한다. <br/>
#### Sliding Expiration(슬라이딩 만료)
지정된 기간 내에 데이터에 액세스하는 경우 만료 시간을 연장한다. <br/>
지정된 기간 동안 사용하지 않을 경우 만료되어야 하는 경우에 유용한다. <br/>
#### Priority (우선권)
메모리 압력으로 인해 발생하는 정리에 대해 유지 우선권을 정하는 것이다. <br/>
Memory Pressure(메모리 압력) <br/>
인메모리 캐싱은 서버에서 사용 가능한 메모리에 직접적인 영향을 받는다.<br/>
ASP.NET Core는 설정된 우선 순위에 따라 메모리가 부족한 상황에서 캐시 항목을 제거할 수 있다.<br/>
Manual Eviction(수동 축출) <br/>
개발자는 캐시된 데이터를 무효화하는 데이터베이스 변경과 같은 특정 조건이 충졸될 때 캐시에서 수동으로 지울 수 있다.

<hr/>

# ASP.NET Core에서의 분산 캐싱
ASP.NET Core에서 분산 캐싱은 여러 서버 또는 인스턴스에서 공유되는 캐시에 데이터를 저장하여 성능과 확장성을 향상시키는 기능이다<br/>
이는 앱이 부하 분산된 클러스터에 배포되거나 물리적으로 분리되어 있는 환경에서 유용하다. <br/>
![image](https://github.com/user-attachments/assets/b634d43b-12e5-4c3a-bab1-ecdc5b51cfef)
# 설정 및 구성
## 분산 캐시 공급자
ASP.NET Core는 Redis, SQL Server 및 NCache를 포함한 여러 분산 캐시 공급자를 지원한다. <br/>
Redis는 성능과 기능으로 인해 인기있는 선택이다. <br/>
## 캐시 구성
앱의 구성 파일(appsettings.json) 또는 코드를 통해 캐시 서비스를 설정한다. <br/>

## 사용
### 데이터 저장
IDistributedCache 인스턴스를 사용하여 캐시에 데이터를 저장할 수 있다. 이 인터페이스는 SetAsync 및 Set과 같은 메서드를 제공하여 
키와 데이터를 저장한다. <br/>
### 데이터 검색
GetAsync 및 Get과 같은 메서드를 사용하여 데이터를 검색할 수 있다. <br/>
### 만료 및 제거
TTL(Time-to-Live) 설정 또는 공간 제약 조건에 따라 데이터를 자동으로 제거하도록 구성할 수 있다. <br/>

## 캐시 무효화(데이터 불일치)에 대한 고려 사항
### 데이터 불일치
### 일관성
캐시와 DB에서 일관성을 보장하는 것은 특히 처리량이 많은 환경에서 어려울 수 있다. <br/>
write-through 또는 write-begind 캐싱과 같은 캐시 전략을 사용하여 이러한 문제를 해결할 수 있다. <br/>

## 분산 캐싱 장점
### 확장성
캐시는 앱 서버와 독립적으로 관리되므로 더 많은 캐시를 추가하여 쉽게 확장할 수 있다. <br/>
### 가용도
캐시는 앱 서버와 독립적으로 유지되므로 앱 서버를 다시 시작하더라도 유지된다. <br/>
### 성능 향상
DB에 대한 왕복 횟수를 줄이고 캐시에서 데이터를 제공함으로써 응답 시간을 크게 줄일 수 있다. <br/>
## 분산 캐싱 단점
### 복잡성
분산 캐시를 구현하고 관리하면 웹앱의 아키텍처가 복잡해진다. <br/>
### 비용
솔루션에 따라 캐시 인프라 호스팅 및 관리와 관련된 추가 비용이 있을 수 있다. <br/>
## 분산 캐싱 사용 사례
고가용성 및 확장성이 필요한 대규모 분산 응용 프로그램(예: 여러 서버에 걸쳐 부하가 분산되는 클라우드 기반 앱)에 선호된다 <br/>
여러 서버 또는 위치에 배포되고 캐시된 데이터에 대한 일관된 보기가 필요한 마이크로서비스 아키텍처 또는 앱에 적합하다. <br/>
서버를 재기동하는 등 서버 메모리가 소실되는 상황에서도 캐시 데이터를 지속할 필요가 있는 앱에 필요하다 <br/>

<br/><br/>
출처 : <br/>
https://dotnettutorials.net/lesson/difference-between-in-memory-caching-and-distributed-caching-in-asp-netcore/ <br/>

<hr/>

# 캐시 전략
앱의 성능 최적화와 사용자 경험 개선을 위해 캐시는 필수 요소로 자리 잡았다. <br/>
캐시는 DB 보다 더 빠른 접근성을 제공하여 성능을 향상시키지만, 사용 목적과 데이터 특성에 따라 적합한 캐시 전략을 선택하는 것이 중요하다. <br/>
대표적인 캐시 전략 세 가지(Cache Aside, Write Through, Write Behind)를 알아보자. <br/>

## Cache Aside
데이터 조회 시 캐시를 먼저 확인하고, 캐시에 데이터가 없을 경우 DB에서 가져오는 방식 <br/>
가져온 데이터는 캐시에 저장되어 이후 요청 시 빠르게 반환된다. <br/>
### 동작 흐름
요청이 들어오면 캐시를 확인한다. <br/>
캐시에 데이터가 없으면 DB에서 조회한다. <br/>
조회된 데이터를 캐시에 저장한다. <br/>
캐시에 저장된 데이터를 반환한다. <br/>

## Write Through
데이터 저장 요청 시 캐시와 DB에 동시에 데이터를 기록하는 방식이다. <br/>
이 방식은 캐시에 항상 최신 데이터를 유지할 수 있도록 설계 되어있다. <br/>
### 동작 흐름
데이터 저장 요청 시 캐시와 DB에 저장한다. <br/>
이후 데이터 조회 요청 시 항상 최신 데이터가 캐시에 존재한다. <br/>

### 장점
캐시와 DB 간 데이터 일관성이 유지된다. <br/>
데이터 조회 시 항상 최신 데이터를 제공한다. <br/>
### 단점
#### 저장 시에 딜레이
캐시와 DB에 데이터를 동시에 기록하므로 저장 작업이 느리다. <br/>
#### 메모리 낭비
자주 사용되지 않는 데이터도 캐시에 저장되기 때문에 캐시 메모리를 비효율적으로 사용할 수 있다. <br/>

## Write Behind
데이터 저장 요청 시 캐시에만 기록, 일정 시간 간격으로 캐시의 데이터를 DB에 기록하는 방식 (Batch 작업) <br/>

### 동작 흐름
데이터 저장 요청 시 캐시에 데이터를 기록한다. <br/>
일정 시간 간격을 두고 주기적으로 캐시의 데이터를 DB에 기록한다. <br/>
데이터 조회 요청 시, 캐시에 저장된 데이터를 바로 반환한다. <br/>

### 장점
저장 작업이 비동기로 처리됨으로 응답 속도가 빠르다. <br/>
데이터 저장 요청이 많을 경우, DB 부하를 줄이고 성능을 최적화할 수 있다. <br/>

### 단점
#### 데이터 손실
캐시에 기록된 데이터가 주기적으로 DB에 저장되기 때문에 저장 주기 전에 캐시가 삭제되거나 장애가 발생하면 데이터 손실 가능성이 있다. <br/>
#### 일관성
DB와 캐시 간 일관성 문제가 발생할 수 있다. <br/>

# 캐시 전략 선택 시에 고려 항목
데이터 조회와 저장의 빈도 차이 (캐시의 주목적이 읽기 성능 최적화 or 쓰기 성능 최적화) <br/>
데이터의 실시간성이 중요한가 <br/>
캐시와 DB 간 일관성이 중요한가 <br/>

## 추가 내용
캐시는 앱의 성능 개선에 매우 중요한 역할을 하지만, 무작정 사용하는 것은 피해야 한다. <br/>
데이터 특성, 시스템 요구사항, 업무 로직에 따라 적합한 캐시 전략을 선택하고 설계하는 것이 중요하다. <br/>
위에서 살펴본 전략을 단일로 사용하거나 조합하여 사용할 수 있다. <br/>

출처 : <br/>
https://velog.io/@yoseb95/%EC%BA%90%EC%8B%9C-%EC%A0%84%EB%9E%B5%EC%9D%98-%EC%9D%B4%ED%95%B4-Cache-Aside-Write-Through-Write-Behind <br/>
<hr/>
