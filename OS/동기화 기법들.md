# 1. condition variable (조건 변수)
멀티스레드 프로그래밍에서 스레드들이 특정 조건이 만족할 때까지 기다리게 하기 위해 사용하는 동기화 도구.<br/>
동기화를 사용할 때 어느 특정 시점(시간이나 이벤트 받을 때까지)에 busy waiting 없이 대기하고 싶을 때 사용.<br/>

생산자-소비자 모델에서 주로 사용한다.<br/>

### 사용 예제
```c++
mutex m;
condition_variable cv;
queue<int> q;

void producer() {
  while (true) {
    // 락 걸고 삽입
    {
      lock_guard<mutex> lock(m);
      q.push(1);
    }

    // 삽입됬음을 알림
    cv.notify_all();
  }
}
void consumer() {
  while (true) {
    // 락 걸고
    unique_lock<mutex> lock(m);

    // 큐가 비어있으면 wait, 비어있지 않으면 진행
    while (q.empty())
      cv.wait(lock);

    // 진행되는 코드
    int data = q.front();
    q.pop();
  }
}

int main() {
  //
  thread t1(consumer);
  thread t2(consumer);
  thread t3(producer);

  //
  t1.join(); t2.join(); t3.join();
}
```
### 동작 과정
1) consumer 스레드
* 락 획득 후 cv.wait에서 블로킹

2) producer 스레드
* 락 획득 후 큐에 삽입 후 notify

3) consumer 스레드
* notify 받고 블록 -> runnable 상태 변경.
* runnable이 되면 락 획득 시도
* 락 획득 실패하면 블로킹
* 락 획득하면 조건 확인
* -> true: 락을 유지한 채 작업
* -> false: 락을 반납하고 블로킹

### spurious wakeup(가짜 깨어남)
condition variable을 쓸 때 나타나는 현상으로 notify/signal을 받지 않았음에도 wait 상태에서 깨어나는 현상.<br/> 

운영체제나 스레드 라이브러리의 구현상 한계 때문에 여러 스레드가 동시에 깨어나거나, 시스템 인터럽트, 또는 내부 최적화 등의 이유로 예상치 못하게 깨어날 수 있다.<br/>

가짜로 깨어나는 현상 자체를 막을 수 있는 방법이 없기 때문에 해결 방법으로는 깨어나더라도 조건을 확인해서 옳은 상황인지
확인하고 작업하도록 설계한다.<br/>

### 해결법
위에 말을 정리하면 아래와 같이 된다.<br
* 가짜 깨어남을 막을 방법이 없음 == 가짜 깨어남은 발생한다 -> 
* 가짜 깨어남이 발생하더라도 조건을 확인하고 문제가 없으면 실행한다.

```c++
void consumer() {
  /*--------------------------------------------------------------------
    그래서 코드에서 이 부분이 가짜 깨어남으로 깨어나더라도 -> 조건 확인 -> 
    조건 불만족(큐가 비어있음) -> 락 반납 후 대기
    큐에 뭔가 있음 -> 락을 유지한 채, 코드 진행
  -------------------------------------------------------------------ㅇ-*/
  while (q.empty())
    cv.wait(lock);

  // 위의 코드와 같은 코드로, 일반적으로는 wait에 predicate이 있는 버전을 사용한다.
  cv.wait(lock, [] { !q.empty(); });
}
```
추가 내용 : wait(lock) 버전은 무조건 블로킹, wait(lock, predicate) 버전은 처음에 조건이 이미 만족된다면 블로킹하지 않고 
깨어날 때마다 조건 자동으로 재확인한다.<br/>

<br/><br/>

# 2. mutex
## mutex

mutex - 가장 기본
recursive_mutex - 재귀 락
shared_mutex - 동시 읽기 가능, 쓰기 단독

mutex, recursive_mutex, shared_mutex.<br/>

```c++
/*-------------------------------
mutex
가장 기본.
--------------------------------*/
std::mutex m;
{
  std::lock_guard<std::mutex> lock(m);
  // 크리티컬 섹션
}
/*--------------------------------
recursive_mutex

--------------------------------*/
std::recursive_mutex rm;7


std::unique_lock<std::recursive_mutex> lock(rm);
/*
shared_mutex

*/
std::shared_mutex sm;
std::unique_lock<std::shared_mutex> lock(sm);

lock.lock_shared();
lock.lock_shared();

```


### mutex
가장 기본

### recursive_mutex

### shared_mutex


* mutex
  가장 기본
* recursive_mutex
  중첩 가능
* shared_mutex
  


## mutex RAII 래퍼
lock_guard, unique_lock, shared_lock.<br/>



lock_guard
가장 간단, 생성 시 lock, 소멸 시 unlock

unique_lock
lock, unlock 타이밍을 본인이 조절 가능
그 외에도 lock_guard 보다 더 많은 기능

# 그 외
packaged task
async






