
# 메모리풀
## 메모리풀 사용, 필요 이유
1. 시스템 콜 오버헤드
   * 일반 malloc/new는 시스템콜을 호출해 느린 반면 메모리풀을 사용하면 시스템콜을 사용하지 않아 빠르다.
   * 시스템콜 횟수를 줄이는 것에 관점
2. 메모리 단편화 방지
   * 단편화가 발생하면 실제 용량이 남는데 못 사용하게 되는 상황이 발생한다.
3. 메모리 오버헤드
   * 운영체제(윈도우 힙 매니저)에서 메모리를 할당하면 해당 메모리 공간을 관리하기 위한 부가적인 데이터들(메타 데이터) 때문에 메모리를 더 사용하게 된다.
4. 캐시 효율성
   * 연속된 메모리 영역을 사용하므로 cpu 캐시 히트율이 높아진다.
   * 데이터 지역성(locality)이 개선된다.

게임 엔진, 네트워크 서버, 데이터베이스 등 고성능이 요구되는 시스템에서 많이 활용된다.
다만 사용 패턴이 예측 가능하고 비슷한 크기의 객체를 많이 다룰 때 가장 효과적이다.

## 메모리 단편화(Fragmentation)
<img width="733" height="416" alt="image" src="https://github.com/user-attachments/assets/c0722f95-b649-4797-8428-5d1db73ad01d" /><br/>
* 1~3: first->third까지 차례대로 메모리 할당
* 4: 중간에 second 메모리 할당 해제
* 새로운 공간(16을 초과하는) 할당 필요
* 공간 없어서 할당 못함.

위와 같이 빈 공간들이 발생하게 되어 메모리 공간을 옳게 사용하지 못하게 되는 것을 메모리 단편화라고 한다.<br/>
여기서 내부 단편화와 외부 단편화로 나뉘게 되는데

* 외부 단편화
  * 할당하는 메모리 공간 사이에 빈 공간이 있어서 연속적으로 할당하기 힘든 경우.
* 내부 단편화
  * 할당된 메모리 공간을 다 사용하지 않는 경우.

## 메모리 오버헤드(메타 데이터)


## 메모리풀 구현



출처: <br/>
https://m.blog.naver.com/ruvendix/221333044853 <br/>
<hr/>
