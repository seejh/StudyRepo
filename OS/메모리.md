
# 메모리풀
## 메모리 할당
### 고정 크기(fixed)
고정된 크기로 할당.
```
[64][64][64][64]....
```

### 가변 크기(variable)
요청 크기에 맞춰 할당.
```
[128][64][32][80]...
```




## 메모리풀 사용, 필요 이유
1. 시스템 콜 오버헤드
   * 일반 malloc/new는 시스템콜을 호출해 느린 반면 메모리풀을 사용하면 시스템콜을 사용하지 않아 빠르다.
   * 시스템콜 횟수를 줄이는 것에 관점
2. 메모리 단편화 방지
   * 단편화가 발생하면 실제 용량이 남는데 못 사용하게 되는 상황이 발생한다.
3. 메모리 오버헤드
   * 운영체제(윈도우 힙 매니저)에서 메모리를 할당하면 해당 메모리 공간을 관리하기 위한 부가적인 데이터들(메타 데이터) 때문에 메모리를 더 사용하게 된다.
4. 캐시 효율성
   * 연속된 메모리 영역을 사용하므로 cpu 캐시 히트율이 높아진다.
   * 데이터 지역성(locality)이 개선된다.

## 메모리 할당
### 고정 크기 할당(Fixed)
미리 정해진 크기 규격으로 할당.-
장:구현이 단순, 할당과 해제 비용이 적다.
단:내부 단편화, 메모리 사용 효율 낮다.

### 가변 크기 할당(Variable)
필요로 하는 크기만큼 동적으로 할당하는 방식.

장: 메모리 사용 효율이 높다.
단: 할당과 해제에 대한 비용이 높다.


## 메모리 단편화(Fragmentation)
### 내부 단편화
할당된 메모리 공간에 비해 실제 사용하는 공간이 적어서 빈 공간만큼 낭비.
```
// 할당 16, 사용 12, 미사용4
[       사용       |미사용]
```
### 외부 단편화
메모리 할당,해제를 반복하여 연속적이지 않은 빈 공간들이 늘어나는 경우<br/>
메모리 공간이 파편화.
```
// 16 할당 a
[a][][][][][]

// 16 할당 b
[a][b]

// 16 할당 c
[a][b][c]

// b 할당 해제
[a][16 빈 공간][c]

// 20 할당 d
[a][16 빈 공간][c][d][빈 공간]...
```


## 메모리 오버헤드(메타 데이터)


## 메모리풀 구현



출처: <br/>
https://m.blog.naver.com/ruvendix/221333044853 <br/>
<hr/>
