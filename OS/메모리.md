
# 메모리풀
## 메모리 할당
### 고정 크기(fixed)
고정된 크기로 할당.
```
[64][64][64][64]....
```

### 가변 크기(variable)
요청 크기에 맞춰 할당.
```
[128][64][32][80]...
```




## 메모리풀 사용, 필요 이유
1. 시스템 콜 오버헤드
   * 일반 malloc/new는 시스템콜을 호출해 느린 반면 메모리풀을 사용하면 시스템콜을 사용하지 않아 빠르다.
   * 시스템콜 횟수를 줄이는 것에 관점
2. 메모리 단편화 방지
   * 단편화가 발생하면 실제 용량이 남는데 못 사용하게 되는 상황이 발생한다.
3. 메모리 오버헤드
   * 운영체제(윈도우 힙 매니저)에서 메모리를 할당하면 해당 메모리 공간을 관리하기 위한 부가적인 데이터들(메타 데이터) 때문에 메모리를 더 사용하게 된다.
4. 캐시 효율성
   * 연속된 메모리 영역을 사용하므로 cpu 캐시 히트율이 높아진다.
   * 데이터 지역성(locality)이 개선된다.

## 메모리 할당
### 고정 크기 할당(Fixed)
미리 정해진 크기 규격으로 할당.-
장:구현이 단순, 할당과 해제 비용이 적다.
단:내부 단편화, 메모리 사용 효율 낮다.

### 가변 크기 할당(Variable)
필요로 하는 크기만큼 동적으로 할당하는 방식.

장: 메모리 사용 효율이 높다.
단: 할당과 해제에 대한 비용이 높다.


## 메모리 단편화(Fragmentation)
### 내부 단편화
할당된 메모리 공간에 비해 실제 사용하는 공간이 적은 경우(=다 사용 안함).
주로 고정 분할 방식에서 발생.
### 외부 단편화



<img width="733" height="416" alt="image" src="https://github.com/user-attachments/assets/c0722f95-b649-4797-8428-5d1db73ad01d" /><br/>
* 1~3: first->third까지 차례대로 메모리 할당
* 4: 중간에 second 메모리 할당 해제
* 새로운 공간(16을 초과하는) 할당 필요
* 공간 없어서 할당 못함.

위와 같이 빈 공간들이 발생하게 되어 메모리 공간을 옳게 사용하지 못하게 되는 것을 메모리 단편화라고 한다.<br/>
여기서 내부 단편화와 외부 단편화로 나뉘게 되는데

* 외부 단편화
  * 할당하는 메모리 공간 사이에 빈 공간이 있어서 연속적으로 할당하기 힘든 경우.
* 내부 단편화
  * 할당된 메모리 공간을 다 사용하지 않는 경우.

## 메모리 오버헤드(메타 데이터)


## 메모리풀 구현



출처: <br/>
https://m.blog.naver.com/ruvendix/221333044853 <br/>
<hr/>
