# 프로세스
## 1. 프로그램
디스크에 저장되어 컴퓨터 시스템에 실행 요청 되기 전의 상태.

## 2. 프로세스
실행을 위해 시스템(커널)에 등록되어 실행 대기 또는 실행 중인 작업(프로그램).<br/>
커널에 등록되어 커널의 관리하에 있는 작업<br/>
프로세스 관리 블록(PCB)를 할당 받은 작업<br/>

### 2-1) 프로세스 종류
* 시스템 (커널) 프로세스:<br/>
모든 시스템 메모리와 프로세서의 명령에 액세스 할 수 있는 프로세스.<br/>
프로세스 실행 순서 제어, 다른 사용자 및 커널 영역 보호, 사용자 프로세스 생성.

* 사용자 프로세스:<br/>
사용자 코드를 수행하는 프로세스.
  
### 2-2) 프로그램 -> 프로세스
<img width="1072" height="358" alt="image" src="https://github.com/user-attachments/assets/f2b410de-048a-4c51-ac47-b9a0974fc329" /><br/>

## 3. 자원 (Resource)의 개념
커널의 관리 하에 프로세스에게 할당/반납되는 수동적 개체.<br/>

### 3-1) 자원의 분류
* H/W resources:<br/>
Processor, memory, disk, monitor, keyboard, ....

* S/W resources:<br/>
Message, signal, files, installed SWs, ...

## 4. PCB(Process Control Block)
OS가 프로세스 관리에 필요한 정보 저장.<br/>
프로세스 생성 시, 생성된다.<br/>
<img width="713" height="438" alt="image" src="https://github.com/user-attachments/assets/d7b9f1c8-bcaa-4e65-af98-e05c1a1cfc6d" /><br/>

### 4-1) PCB가 관리하는 정보
<table>
  <tr>
    <td>PID(Process Identification Number)</td>
    <td>프로세스 고유 식별 번호</td>
  </tr>
  <tr>
    <td>스케줄링 정보</td>
    <td>프로세스 우선순위 등과 같은 스케줄링 관련 정보</td>
  </tr>
  <tr>
    <td>프로세스 상태</td>
    <td>자원 할당, 요청 정보</td>
  </tr>
  <tr>
    <td>메모리 관리 정보</td>
    <td>Page Table, Segment Table 등</td>
  </tr>
  <tr>
    <td>입출력 상태 정보</td>
    <td>할당 받은 입출력 장치, 파일 등에 대한 정보</td>
  </tr>
  <tr>
    <td>문맥 저장 영역(Context Save Area)</td>
    <td>프로세스의 레지스터 상태를 저장하는 공간 등</td>
  </tr>
  <tr>
    <td>계정 정보</td>
    <td>(다중 사용자인 경우)자원 사용 시간 등을 관리</td>
  </tr>
</table>

## 5. 프로세스의 상태
프로세스는 생성된 후에 여러 가지 상태로 변경되어 가며 작업을 하게 된다.<br/>
이 상태는 자원 간의 상호작용에 의해 결정이 된다.

### 할당된 자원에 따른 프로세스 상태
<img width="845" height="277" alt="image" src="https://github.com/user-attachments/assets/d5e7541a-506d-4440-92aa-3864b7fa7c3f" /><br/>

### 프로세스의 상태 전이
<img width="935" height="422" alt="image" src="https://github.com/user-attachments/assets/8889b8c2-c506-4ab1-97fe-7087821eac0c" /><br/>
이거를 그냥 보기는 힘들기 때문에 한 구간씩 잘라서 본다.<br/>

### 5-1) Created State
처음에 프로그램을 가동하여 실행된 상태.<br/>
<img width="599" height="274" alt="image" src="https://github.com/user-attachments/assets/d0356870-f9af-4e55-a276-23da4740bc28" /><br/>
프로그램 실행 -> 작업을 커널에 등록 -> PCB 할당 및 프로세스 생성<br/>

이후 상태 전이는 <br/>
사용할 수 있는 메모리 공간이 있으면 Created -> Ready.<br/>
사용할 수 있는 메모리 공간이 없다면 Created -> Suspended Ready.<br/>

### 5-2) Ready State
프로세서(CPU) 외에 다른 모든 자원을 할당 받은 상태로 프로세서 할당을 대기하는 상태.<br/>
<img width="363" height="228" alt="image" src="https://github.com/user-attachments/assets/09370d86-f0ce-4a33-9009-776b21408c8d" /><br/>
* Dispatch(= Schedule): CPU를 할당함.

CPU를 할당 받으면 Ready -> Running.<br/>

### 5-3) Running State
프로세서와 필요한 자원을 모두 할당 받아 실제로 동작하는 상태.<br/>
<img width="549" height="228" alt="image" src="https://github.com/user-attachments/assets/3a3c73cf-1cea-4023-b203-f7c4970546f7" /><br/>
계속 실행하는 것은 아니고 아래 두가지 중 하나의 이유로 인해 상태가 전이된다.<br/>

#### 5-4-1) Preemption
프로세서 스케줄링에 의해 변경(time-out, priority changes).<br/>
할당된 시간이 끝나거나(time-out), 우선순위 변경(priority changes)되면<br/>
Running -> Ready로 상태가 변경된다.<br/>

#### 5-4-2) Block/Sleep
I/O 요청 등에 의해 block 된다.<br/>
Running -> Sleep으로 상태 변경.<br/>

### 5-5) Block/Sleep State
<img width="572" height="253" alt="image" src="https://github.com/user-attachments/assets/11f6e3a1-97ad-49cf-826a-581a18d81377" /><br/>
프로세서 외에 다른 자원을 기다리는 상태.<br/>
자원 할당은 시스템 콜에 의해 이루어짐.<br/>
대기하다가 요청한 I/O 등이 오면 wakeup하여 block/sleep -> ready.<br/>

### Suspended
Suspended Ready, Suspended Block 상태가 있는데 Ready(Active), Block(Active)와의 차이는 
메모리 공간을 할당 받았으면 Active Ready, 메모리 공간을 할당 받지 못 했으면 Suspended Ready.

* 메모리를 할당 받지 못한(빼앗긴) 상태.
* Memory Image를 Swap Device에 보관.
* 커널 또는 사용자에 의해 발생.

* Swap Device: 프로그램 정보 저장을 위한 공간.
* Swap-out(suspended):메모리 공간 할당 해제, 메모리에서 Swap Device.
* Swap-in(resume):메모리 공간을 다시 할당 받음, Swap Device에서 메모리로.

### 5-6) Suspended Ready
메모리가 없이 대기하는 상태.

### 5-7) Suspended Block
I/O 하려고 block 됬는데 메모리도 빼앗긴 상태.

### 5-8) Terminated/Zombie State
프로세스의 수행이 끝난 상태.<br/>
모든 자원 반납하고 커널 내에 일부 PCB 정보만 남아 있는 상태.<br/>

자원을 반납하고 끝나기를 대기하는 상태이고 이후 커널이 PCB 정보를 회수하면 소멸한다.

<img width="743" height="325" alt="image" src="https://github.com/user-attachments/assets/d1862fd0-3633-49c1-95ea-9112ed8e1798" /><br/>
프로세서들은 Ready 큐에서 스케줄러에 의해 Dispatch되는 것을 대기.<br/>

Sleep 상태에서 프로세서 외에 다른 자원들을 기다리고 있으며 자원 별로 큐가 따로 존재한다.<br/>
I/O, Device 등 여러 자원 별로 큐에 담겨서 대기한다.

## 6. 인터럽트(Interrupt)
예상치 못한(Unexpected), 외부에서 발생한 이벤트(external events).

* 인터럽트 종류:<br/>
I/O, Clock, Console, Program, Machine, Inter-process, System call2

### 인터럽트 처리 과정 
<img width="948" height="385" alt="image" src="https://github.com/user-attachments/assets/f9bdb1d6-b029-4dc3-8b12-6920d56cca67" /><br/>
1. 프로세스 동작 중 인터럽트 발생
2. 커널이 개입하여 프로세스 중단
3. 인터럽트 발생한 곳, 원인 파악
4. 그에 맞는 조치(ISR, 인터럽트 서비스 루틴) 찾아서 호출.

### 인터럽트 처리 과정 상세
<img width="855" height="563" alt="image" src="https://github.com/user-attachments/assets/ddcbec5b-3761-431a-8d8d-e6cd90f69c82" /><br/>
1. 프로세스(P.i) 동작 중 인터럽트 발생
2. 커널이 개입하여 프로세스 중단, PCB(PCB.i)에 현재 컨텍스트 저장. -> 현재 프로세스가 밀려남.
3. 커널 인터럽트 핸들러에서 인터럽트 원인과 발생한 곳 파악. - IH(Interrupt Handling)
4. 원인에 맞는 ISR을 호출하여 수행. - IS(Interrupt Service)
5. ISR 종료
6. 프로세서 스케줄러에서 Ready 중인 프로세스 큐에서 프로세스(PCB.j)를 가져와서 수행.

## 7. Context Switching (문맥 교환)
### Context
프로세스와 관련된 정보들의 집합.<br/>

CPU는 어떤 작업을 할 때 메모리에 있는 데이터를 CPU 레지스터에 올려서 처리한다.<br/>
프로세스에 CPU가 할당되면 메모리의 데이터를 CPU에 레지스터에 올리고<br/>
프로세스에서 할당이 해제되면 레지스터의 작업중인 데이터를 메모리에 저장한다.<br/>

여기서 CPU를 할당 받아 메모리에서 레지스터로 옮기는 것을 Context Restoring.<br/>
CPU 사용이 끝나서 레지스터의 데이터를 메모리로 저장시키는 것을 Context Saving.<br/>

### Context Switching
커널이 개입하여 실행 중인 프로세스의 컨텍스트를 저장하고 실행 할 다른 프로세스의 컨텍스트를 복구하는 것.

### Context Switching Overhead
컨텍스트 스위칭에 소요되는 비용.<br/>
OS 마다 다르며 OS의 성능에 큰 영향을 준다.<br/>

따라서 불필요한 컨텍스트 스위칭을 줄이는 것이 중요하다.<br/>
이 비용을 줄이는 법 중 하나는 프로세스 대신 스레드를 사용하는 것이다.
