# 시스템 콜 호출 시 컨텍스트 스위치가 일어나는가

### Windows C++ 환경에서 확인
시스템 콜(예: GetCurrentProcessId() & ReadFile()을 호출할 때) 컨텍스트 스위치가 실제로 일어나는지 확인한다.<br/>

NtQueryInformationThread()라는 윈도우 Native API를 사용해야 한다. 
이 함수는 THREAD_BASIC_INFORMATION 구조체를 반환하고, ContextSwitches 카운터를 읽을 수 있다.
```c++
#include<windows.h>
#include<iostream>
#include<thread>
#include<chrono>

extern "C" {
  NTSYSAPI NTSTATUS NTAPI NtQueryInformationThread(
    HANDLE ThreadHandle,
    THREADINFOCLASS ThreadInformationClass,
    PVOID ThreadInformation,
    ULONG ThreadInformationLength,
    PULONG ReturnLength
  );
}
```

 ### 해석
 getpid()는 시스템 콜을 100만 번 호출했지만 컨텍스트 스위치가 없다.
 유저 <-> 커널 모드 전환만 일어났다.(mode switch)

 read()는 데이터가 없을 때 스레드를 자발적으로 block, 자발적 컨텍스트 스위치 1회 발생

C++에서 시스템 콜을 실행하면 모드 전환은 발생한다. 컨텍스트 스위치는 블로킹 상황에서만 발생한다.


































# 시스템 콜을 했을 때 컨텍스트 스위치가 일어나는가?
* C++에서
* 단순 시스템 콜(예: getpid(), 컨텍스트 스위치 거의 없음)과
* 블로킹(예: read(), 스레드 상태 블록으로 인한 컨텍스트 스위치 발생) 비교

리눅스용 코드
```c++

// /proc/self/status에서 context switch 횟수 읽기
void read_context_switches(long& voluntary, long& involuntary) {
  ifstream status("/proc/self/status");
  string line;

  while (getline(status, line)) {
    if (line.rfind("voluntary_ctxt_switches:", 0) == 0) {
      voluntary = stol(line.substr())
    }
  } 
}

int main() {
  long v_before, nv_before, v_after, nv_after;

  cout << "Case 1: getpid() = (system call, no blocking)" << endl;
  read_context_switches(v_before, nv_before);
  for (int i = 0; i < 100'0000; i++)
    getpid();
  read_context_switches(v_after, nv_after);

  cout << "Case 2: read() = blocking()" << endl;
  
}
```

## 해석
### Case 1: getpid() => (System call, No Blocking)
getpid()는 시스템 콜을 100만 번 호출했지만 컨텍스트 스위치가 없다. (유저<->커널 모드 전환만 발생)
### Case 2: read() => Blocking
read()는 데이터가 없을 때 스레드를 자발적으로 block하므로 컨텍스트 스위치 1 발생

### 추가 정리 & 결론
<table>
  <tr>
    <td>상황</td>
    <td>모드 전환</td>
    <td>Context Switch</td>
    <td>설명</td>
  </tr>
  <tr>
    <td>getpid()</td>
    <td></td>
    
  </tr>
  <tr>
    <td>send() (논 블로킹)</td>
  </tr>
</table>



