# 메인 메모리 관리

### 프로세스
* 프로그램이 실행중인 상태.
* 프로그램이 실행되어 명령어들이 메모리에 올라간 상태.

### 메모리
* byte(8bit)의 집합.
* 각 바이트마다 각자의 주소가 있음.

CPU는 메모리로부터 프로그램 카운터(PC, Program Count)가 가리키는 주소에 있는 명령어를 인출(fetch)해서 실행한다.
이 명령어를 통해 메모리에 저장하던가 로드해올 수 있다.

<img width="459" height="461" alt="image" src="https://github.com/user-attachments/assets/c4c8fcb6-e2a9-4534-bce8-faaeb3647028" />


<hr/><br/><br/>

# Base Register, Limit Register?
하드웨어 수준에서 프로세스의 메모리 접근을 보호하기 위해 사용되는 레지스터.
CPU/MMU 내부에 실제로 존재하는 특수 목적 레지스터.
OS가 프로세스를 전환할 때만 변경.

### 레지스터
흔히 레지스터에는 두 가지 분류가 있다.
<table>
  <tr>
    <td>구분</td><td>설명</td><td>예시</td>
  </tr>
  <tr>
    <td>범용 레지스터(General-Purpose Register)</td>
    <td>프로그래머가 명령어로 직접 접근할 수 있는 CPU 내부 저장소</td>
    <td>EAX, RAX, SP, PC 등</td>
  </tr>
  <tr>
    <td>특수 목적 레지스터(Special-Purpose Register)</td>
    <td>프로그래머가 직접 접근할 수 없고, 하드웨어/Os가 제어하는 레지스터</td>
    <td>CR3, segment base, MMU control register 등</td>
  </tr>
</table>

<hr/><br/><br/>

# MMU(Memory Management Unit)
CPU 안에서 주소 변환(Address Translation)과 메모리 보호(Protection)를 담당하는 하드웨어이다.<br/>

프로세스가 메모리를 접근할 때
* 프로세스 입자에서의 주소(Logical/Virtual Address)와
* 실제 물리 메모리 주소(Physical Address)가 다르다.

MMU는 이 둘을 변환한다.
CPU(가상 주소) -> MMU + Page 테이블 -> 물리 주소

### 페이지 테이블
<table>
  <tr><td>용어</td><td>의미</td></tr>
  <tr>
    <td>Page</td>
    <td>프로세스의 논리 주소 공간을 일정 크기로 나눈 단위(보통 4KB)</td>
  </tr>
  <tr>
    <td>Frame</td>
    <td>물리 메모리(RAM)를 같은 크기로 나눈 단위</td>
  </tr>
  <tr>
    <td>Page Table</td>
    <td>각 페이지가 어떤 프레임에 매핑되는지를 저장한 테이블</td>
  </tr>
</table>

예시)<br/>
이러한 매핑되는 정보를 가지고 있는 게 페이지 테이블(Page Table)이다.
<table>
  <tr>
    <td>페이지 번호</td><td>프레임 번호</td><td>설명</td>
  </tr>
  <tr>
    <td>0</td><td>5</td><td>가상 페이지 0번은 물리 프레임 5번에 있음</td>
  </tr>
  <tr>
    <td>1</td><td>9</td><td>가상 페이지 1번은 물리 프레임 9번에 있음</td>
  </tr>
  <tr>
    <td>3</td><td>-</td><td>아직 메모리 없음(swap 영역에 있다.)</td>
  </tr>
</table>






