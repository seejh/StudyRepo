# C++ 블로킹 소켓
소켓을 그냥 생성하면 기본적으로 블로킹 방식으로 동작한다.
"블로킹"은 디바이스에 처리 요청을 걸어 놓고 응답을 대기하는 함수를 호출할 때 스레드에서 발생하는 대기 현상.
블로킹이 발생하는 스레드에서는 스레드 상태 block/wait으로 CPU 연산을 하지 않는다.

블로킹 모드의 소켓을 통해 동기I/O 함수(send, recv 등)를 호출하면 소켓의 커널 송수신 버퍼 상황에 따라 Block이 걸린다.

### Send
유저 버퍼의 데이터를 커널의 송신 버퍼로 복사한 후 운영체제

유저 버퍼의 내용이 커널 송신 버퍼로 복사가 되면 리턴
소켓 송신 버퍼의 기본 크기는 수천 바이트 ~ 만 바이트
송신 버퍼에 복사된 데이터는 운영체제에 의해 송신되고 송신 버퍼를 비운다.


### Recv


## Client
```c++
#include<iostream>
#include<winsock2.h>
#include<mswsock.h>
#include<ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")

using namespace std;

int main() {

  // winsock 초기화
  WSADATA wsaData;
  if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
    return 0;

  // TCP 소켓 생성
  SOCKET sock = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (sock == INVALID_SOCKET) {
    return 0;
  }

  // 서버 주소
  sockaddr_in serverAddr;
  ::memset(&serverAddr, 0, sizeof(serverAddr));
  serverAddr.sin_family = AF_INET;
  serverAddr.sin_port = htons(7777);
  inet_pton(AF_INET, "127.0.0.1", &serverAddr.sin_addr);

  // Connect
  if (SOCKET_ERROR == ::connect(sock, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr))) {
    int errCode = WSAGetLastError();
    cout << "Connect Failed, ErrorCode: " << errCode << endl;
    closesocket(sock);
    WSACleanup();
    return 0;
  }

  // Connect 성공
  cout << "Success, Connected to Server" << endl;

  // Send
  char sendBuffer[100] = "This Msg From Client";
  int sendLen = 0;

  while (true) {

    sendLen = ::send(sock, sendBuffer, sizeof(sendBuffer), 0);
    if (sendLen <= 0) {
      int errCode = WSAGetLastError();
      cout << "SendLen <= 0 Failed, ErrorCode: " << errCode << endl;
      break;
    }

    Sleep(2000);
  }

  closesocket(sock);
  WSACleanup();
}
```

## Server
```c++
#include<iostream>
#include<winsock2.h>
#include<mswsock.h>
#include<ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")
using namespace std;

int main() {
  // winsock 초기화
  WSADATA wsaData;
  if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
    return 0;

  // 소켓 생성
  SOCKET listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (listenSocket == INVALID_SOCKET)
    return 0;

  // 서버 주소 설정
  sockaddr_in serverAddr;
  ::memset(&serverAddr, 0, sizeof(serverAddr));
  serverAddr.sin_family = AF_INET;
  serverAddr.sin_port = htons(7777);
  serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);

  // 주소 바인드
  if (SOCKET_ERROR == ::bind(listenSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr)))
    return 0;

  // 리슨
  if (SOCKET_ERROR == ::listen(listenSocket, SOMAXCONN))
    return 0;

  // 여기서부터 리스닝
  cout << "Server Listening... << endl;

  // 연결될 클라이언트 주소
  sockaddr_in clientAddr;
  ::memset(&clientAddr, 0, sizeof(clientAddr));
  int clientAddrLen = sizeof(clientAddr);

  // Accept
  SOCKET clientSocket = ::accept(listenSocket, (sockaddr*)&clientAddr, &clientAddrLen);
  if (clientSocket == INVALID_SOCKET) {
    int errCode = WSAGetLastError();
    cout << "Accept Failed, ErrorCode: " << errCode << endl;
    return 0;
  }

  // 소켓 연결됨
  cout << "Client Connected." << endl;

  // recv
  char recvBuffer[1000];
  while (true) {
    int recvLen = ::recv(clientSocket, recvBuffer, sizeof(recvBuffer), 0);
    if (recvLen <= 0) {
      int errCode = ::WSAGetLastError();
      cout << "recvLen <= 0, ErrorCode: " << errCode << endl;
      break;
    }

    cout << "Recv Msg : " << recvBuffer << endl;
  }
}
```

# C++ 논블로킹 소켓
블로킹 소켓 코드에서 아래 내용만 넣어주면 된다.
기본적으로 블로킹 모드로 동작하는 소켓을 논블로킹으로 변경하는 것.
```c++
u_long mode = 1;
ioctlsocket(sock, FIONBIO, &mode);
```



출처 : <br/>
https://marmelo12.tistory.com/287 <br/>



