# C++ 블로킹 소켓
## Client
```c++
#include<iostream>
#include<winsock2.h>
#include<mswsock.h>
#include<ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")

using namespace std;

int main() {

  // winsock 초기화
  WSADATA wsaData;
  if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
    return 0;

  // TCP 소켓 생성
  SOCKET sock = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (sock == INVALID_SOCKET) {
    return 0;
  }

  // 서버 주소
  sockaddr_in serverAddr;
  ::memset(&serverAddr, 0, sizeof(serverAddr));
  serverAddr.sin_family = AF_INET;
  serverAddr.sin_port = htons(7777);
  inet_pton(AF_INET, "127.0.0.1", &serverAddr.sin_addr);

  // Connect
  if (SOCKET_ERROR == ::connect(sock, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr))) {
    int errCode = WSAGetLastError();
    cout << "Connect Failed, ErrorCode: " << errCode << endl;
    closesocket(sock);
    WSACleanup();
    return 0;
  }

  // Connect 성공
  cout << "Success, Connected to Server" << endl;

  // Send
  char sendBuffer[100] = "This Msg From Client";
  int sendLen = 0;

  while (true) {

    sendLen = ::send(sock, sendBuffer, sizeof(sendBuffer), 0);
    if (sendLen <= 0) {
      int errCode = WSAGetLastError();
      cout << "SendLen <= 0 Failed, ErrorCode: " << errCode << endl;
      break;
    }

    Sleep(2000);
  }

  closesocket(sock);
  WSACleanup();
}
```

## Server
```c++
#include<iostream>
#include<winsock2.h>
#include<mswsock.h>
#include<ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")
using namespace std;

int main() {
  // winsock 초기화
  WSADATA wsaData;
  if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
    return 0;

  // 소켓 생성
  SOCKET listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (listenSocket == INVALID_SOCKET)
    return 0;

  // 서버 주소 설정
  sockaddr_in serverAddr;
  ::memset(&serverAddr, 0, sizeof(serverAddr));
  serverAddr.sin_family = AF_INET;
  serverAddr.sin_port = htons(7777);
  serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);

  // 주소 바인드
  if (SOCKET_ERROR == ::bind(listenSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr)))
    return 0;

  // 리슨
  if (SOCKET_ERROR == ::listen(listenSocket, SOMAXCONN))
    return 0;

  // 여기서부터 리스닝
  cout << "Server Listening... << endl;

  // 연결될 클라이언트 주소
  sockaddr_in clientAddr;
  ::memset(&clientAddr, 0, sizeof(clientAddr));
  int clientAddrLen = sizeof(clientAddr);

  // Accept
  SOCKET clientSocket = ::accept(listenSocket, (sockaddr*)&clientAddr, &clientAddrLen);
  if (clientSocket == INVALID_SOCKET) {
    int errCode = WSAGetLastError();
    cout << "Accept Failed, ErrorCode: " << errCode << endl;
    return 0;
  }

  // 소켓 연결됨
  cout << "Client Connected." << endl;

  // recv
  char recvBuffer[1000];
  while (true) {
    int recvLen = ::recv(clientSocket, recvBuffer, sizeof(recvBuffer), 0);
    if (recvLen <= 0) {
      int errCode = ::WSAGetLastError();
      cout << "recvLen <= 0, ErrorCode: " << errCode << endl;
      break;
    }

    cout << "Recv Msg : " << recvBuffer << endl;
  }
}
```

# C++ 논블로킹 소켓
블로킹 소켓 코드에서 아래 내용만 넣어주면 된다.
기본적으로 블로킹 모드로 동작하는 소켓을 논블로킹으로 변경하는 것.
```c++
u_long mode = 1;
ioctlsocket(sock, FIONBIO, &mode);
```


