1. 인터럽트, 컨텍스트 스위치

* 인터럽트
CPU가 현재 실행 중인 작업을 잠시 멈추고 커널의 ISR를 수행 후 다시 복귀 하는 것.

수순
작업 중 -> 인터럽트 발생 -> 현재 작업 내용 저장 -> ISR 수행 -> 복귀

* 컨텍스트 스위치
CPU의 실행 주체(스레드) 교체

수순
작업 중 -> 프로세스 스케줄링 발생 -> 현재 작업 내용 저장 -> ready 큐로 이동
이후 다른 스레드 수행
---------------------------------------------------------------------------------------------------
2. 컨텍스트 스위치를 줄이기 위한 실질적으로 노력해야 할 방향
컨텍스트 스위치는 성능에 좋지 않다 -> 하지만 무조건 발생한다.(프로세스 스케줄링)
-> 저런 컨트롤할 수 없는 영역은 제외하고 건드릴 수 있는 영역에서 고려해야 한다.
-> 주로 블로킹으로 인한 컨텍스트 스위치를 막게 된다.

1) 블로킹 I/O, Sleep, Condition Variable Wait
블로킹을 부르는 환경으로 블로킹 => 컨텍스트 스위칭
블로킹 방식 말고 논블로킹 방식으로 변경.

2) 락 경합 최소화
mutex와 같은 동기화 객체를 사용할 때 락 경합에서 밀리면 블록된다.

락 경합 상황
스레드1 락 획득 시도 -> 실패 -> 블록되어 wait 큐에 대기. ->
이후 락을 획득한 스레드2에서 락 해제 -> 스레드1이 블록 해제되어 ready 상태로 변경 ->
cpu를 할당 받고 락 획득 시도

디테일:
운영체제의 mutex 구현은 보통 wait queue를 가진다고 한다.
락을 획득한 스레드에서 unlock()을 하면 mutex 내부의 wait큐에서 블록된 스레드1을 발견하고
스레드1을 block -> ready로 변경.

3) 스레드 남발 금지
CPU 코어 수 < 스레드 수 => 이러한 경우
OS는 스레드를 계속 바꿔 가며 실행해야 된다.
타임 슬라이스마다 컨텍스트 스위치가 발생하게 된다.
CPU는 실제 작업보다 스케줄링/스위칭 오버헤드에 시간을 많이 쓰게 된다.

특히 I/O bound + 많은 스레드 => 최악의 모델
---------------------------------------------------------------------------------------------------
3. 락 경합을 줄이는 방법
1) 임계 구역(critical section) 최소화
임계 구역 길이가 낮을수록 경쟁 가능성 낮아진다.
말 그대로 락 범위에 필요한 부분만 넣어서 최소화 시키는 것.

2) 락 범위를 쪼개기
전역 큰 락 하나 -> 여러 개의 작은 락
큰 map 하나에 전역 락 -> bucket 별 락 사용

3) 락 프리
4) Reader-Writer Lock 사용
읽기가 많은 환경에서 read-lock은 병렬로 허용하고 write-lock만 단독 실행

5) 경합이 많은 데이터는 sharding
하나의 shared 변수 -> 스레드/cpu 별로 분리해서 나중에 merge

예제:
per-thread counter 사용 후 마지막에 sum
CPU 별 allocator(메모리 풀) 사용
---------------------------------------------------------------------------------------------------
4. 스레드 수 문제 해결 방법
1) 스레드 풀 사용
스레드를 무제한 생성하지 않고 필요한 만큼만 유지.
일반적으로 CPU 코어 수에서 플러스 마이너스.

2) event-driven 모델 사용
Node.js, Nginx, epoll


3) 비동기 I/O + async/await 패턴
고성능 서버에서는 필수 전략

4) CPU 바운드 작업은 core 수에 맞춰 제한
CPU 바운드 작업 스레드 수 => 코어 수
I/O 바운드 작업 스레드 수 => 코어 수보다 조금 많게


---------------------------------------------------------------------------------------------------
. I/O?
운영체제가 외부 장치(디스크, 네트워크, 키보드 등)와 데이터를 주고 받는 것을 의미.
* 파일 읽기/쓰기
* 소켓 데이터 수신/송신
* 장치 드라이버 이벤트

mutex unlock() 할 때 스레드를 깨우는 건?
락 해제는 스레드 간 동기화 이벤트, I/O는 외부 장치 이벤트.
여튼 다른거라 함.











** 컨텍스트 스위칭과 스레드 수의 관계

1) CPU 바운드 작업
컨텍스트 스위칭은 성능에 좋지 않다.

내가 CPU 활용율을 한계까지 끌어내야 한다 ->
* 각 코어를 한계까지 사용
* 컨텍스트 스위칭은 최소화

CPU 코어 수만큼만 스레드 사용하고 각 스레드의 사용률을 100퍼센트로


2) I/O 바운드 작업


1. ODBC의 비동기 기능을 직접 사용
2. ODBC는 블로킹으로 쓰되, 스레드풀을 붙여

