
# 스레드
프로세서(CPU) 활용의 기본 단위.<br/><br/><br/>
<img width="500" height="300" alt="image" src="https://github.com/user-attachments/assets/a6569975-227b-4b04-aa6f-1e72e5aa16bc" /><br/>
위 그림은 프로세스의 메모리 공간을 보여주는 그림이다. 현재 하나의 프로세스 안에 여러 스레드가 있다.<br/>
우측은 리소스(힙, 데이터, 코드)에 해당하는 공간으로 공용으로 사용하는 공간.<br/>
좌측은 제어에 해당하는 공간으로 스레드 별로 가지게 된다.<br/>

<br/><br/>
<img width="802" height="440" alt="image" src="https://github.com/user-attachments/assets/f758cc10-8f77-491c-bd96-7fb128d0611d" /><br/>
스레드가 개별로 가지는 요소
* 스레드ID
* Register Set(PC, SP)
* Stack

스레드 별로 본인 작업 공간 스택 영역이 있고 해당 영역을 가리키는 SP, 실행할 명령줄 위치를 나타내는 PC 등 제어를 위한 
정보들이 있다.

<br/><br/>
# 스레드 장.단점 (vs 프로세스)
### 장점 1) 가볍다
스레드는 프로세스보다 생성과 전환(컨텍스트 스위칭) 측면에서 비용이 훨씬 적다.
생성-스레드는 프로세스 내에서 실행 흐름만 추가하면 된다.
컨텍스트 스위칭-메모리 주소 공간을 전환할 필요가 없다.

### 장점 2) 효율적인 자원 공유
프로세스 간에 데이터를 주고 받으려면 IPC(프로세스 간 통신)같은 메커니즘이 필요하지만, 스레드는
프로세스 내에서 메모리 공간을 공유하므로 위와 같은 별도의 처리없이도 데이터를 쉽게 주고 받을 수 있다.

### 장점 3) 메모리 효율성
여러 스레드가 같은 메모리 공간

### 장점 4) 응답성 향상
하나의 스레드가 블로킹 되어도 다른 스레드는 계속 실행될 수 있다.

### 단점) 
공유 자원 접근 시에 동기화 문제 발생.<br/>
한 스레드의 오류가 전체 프로세스를 다운시킬 수 있다.

### 요약
프로세스에 비해 가벼워서 성능적인 측면에서 좋다. 다만 동기화 문제를 컨트롤해야 한다.


<br/><br/>
# 스레드 구분 (유저 레벨, 커널 레벨)
<img width="674" height="400" alt="image" src="https://github.com/user-attachments/assets/5f3e12fb-2213-4332-9a2f-3d06be6b1e7d" /><br/>

### 커널 수준 스레드 (Kernel Thread)
커널 영역에서 생성되고 커널이 관리하는 스레드.<br/>
std::thread 같은 것이 커널 수준 스레드.<br/>

장점<br/>
유저 레벨과는 다르게 완벽하게 병렬로 실행할 수 있다.<br/>
즉, 하나의 스레드가 블로킹 되어도 다른 스레드는 계속 실행할 수 있다.<br/>

단점<br/>
생성/전환 비용이 유저 레벨 스레드보다 높다.<br/>
컨텍스트 스위칭 시 커널 모드 전환이 필요하다<br/>

### 유저 수준 스레드 (User Thread)
유저 영역에서 생성, 관리되는 스레드.
커널은 이 유저 레벨 스레드라는 것을 모르고 프로세스 단위로 자원을 할당.

아래와 같은 것들이 유저 레벨 스레드이다.
* Fiber(Windows Fiber)
* Coroutine (c++20 co_await)
* Boost.Context / Coroutine
* Lua coroutine
* Actor

장점<br/>
생성과 관리의 부하가 적다.
커널 레벨로 전환될 필요가 없다.

단점<br/>
하나의 스레드가 블록되면 모든 스레드가 대기하게 된다.










