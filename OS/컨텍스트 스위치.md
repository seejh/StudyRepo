# 컨텍스트 스위치
CPU가 작업하는 스레드 교체.<br/>

## 컨텍스트 스위치 부하
컨텍스트 스위치가 일어날 때 현재 작업을 저장하고 해야할 작업을 불러오는 등 작업 부하가 있다.<br/>

## 그래서 컨텍스트 스위치는 줄이는 것이 좋다.
다만 컨텍스트 스위치는 실질적으로 무조건 발생하기에 컨트롤할 수 없는 영역을 제외한 건드릴 수 있는 영역에서
줄이는 것을 고려해야 한다.<br/>

## 컨텍스트 스위칭을 줄이는 방법
다만 컨텍스트 스위치는 우리가 컨트롤할 수 없는 프로세스 스케줄링에 의해 발생할 수 밖에 없으므로
최대한 줄이는 방식으로 접근해야 한다.<br/>

CPU를 할당 받아 해당 타임 슬라이스 동안 블로킹으로 인한 컨텍스트 스위칭을 방지하는 것이 주된 방법이다.
### 1. 블로킹 함수 사용 X
블로킹 I/O, Sleep, Condition Variable Wait 등 블로킹을 부르는 함수를 사용하면 현재 스레드가 블록되고
컨텍스트 스위칭이 일어나게 된다. 논블로킹 함수를 사용한다.

### 2. 락 경합
락 경합을 하다가 획득에 실패하면 블로킹되어 컨텍스트 스위칭이 일어난다.<br/>
아래는 락 경합 상황이다.<br/>

스레드1 락 획득 시도 -> 실패 -> 블록되어 컨텍스트 스위칭.<br/>
스레드2에서 락 획득 후 작업 -> 락 해제 -> 스레드1 블록 해제 -> 스레드1 ready -> 스레드1 running -> 락 획득 시도 -> 
성공하면 실행, 실패할 시 위에 반복<br/>

스레드1에서 락 경합에서 밀리면 블로킹되어 락을 획득한 스레드2에서 락을 해제할 때까지 블록되게 된다. 그 후 스레드2에서
락을 놓아주면 스레드1은 블로킹이 해제되어 ready가 되고 cpu를 할당 받기를 대기하게 된다.<br/>

디테일:<br/>
운영체제의 mutex 구현은 보통 내부에 wait queue를 가지고 락 획득을 실패하여 대기하는 스레드들을 담고, 락을 획득한 스레드에서
unlock()하면 해당 큐에서 찾아서 블로킹을 해제한다고 한다.

### 3. 스레드 남발
"CPU 코어 수 < 스레드 수" => 이러한 경우 OS는 스레드를 계속 바꿔가며 실행해야 된다.
타임 슬라이스마다 컨텍스트 스위치가 발생하게 된다. CPU는 실제 작업보다 스케줄링/스위칭 오버헤드에 시간을 많이 쓰게 된다.

이 부분은 조금 더 알아볼 필요가 있음.<br/>




