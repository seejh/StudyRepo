# 1. 정적 라이브러리
프로그램 빌드 시점(컴파일, 링크 시점)에 프로그램 안에 직접 포함되는 라이브러리.

### 동작 방식
1. 컴파일 시, 소스 코드(.c, .cpp)가 오브젝트 파일(.obj 또는 .o)로 만들어진다.
2. 링커가 라이브러리(.lib, .a)의 필요한 부분을 복사해서 실행 파일에 포함.
3. 결과적으로 하나의 완전한 실행 파일(.exe or ELF)이 만들어진다.

### 장점
* 배포 간단: 실행 시 별도의 라이브러리 파일이 필요 없다.
* 의존성이 적다: 실행 환경이 단순.

### 단점
* 라이브러리를 변경하면 프로그램을 다시 빌드해야 한다.
* 같은 라이브러리가 여러 프로그램에 포함될 경우 메모리 낭비(중복)
* 실행 파일 크기가 커진다.

# 2. 동적 라이브러리
프로그램 실행 중(runtime)에 외부에서 로드되어 사용되는 라이브러리.

* Windows: .dll (Dynamic Link Library)
* Linux/Unix: .so (Shared Object)
* macOS: .dylib

### 동작 방식
1. 컴파일 시, 링커는 함수가 들어있는 외부 라이브러리의 참조 정보만 포함.
2. 실행 시, 운영체제가 필요한 동적 라이브러리를 메모리에 로드.
3. 여러 프로그램이 하나의 라이브러리를 공유 가능.

### 장점
* 메모리 절약: 여러 프로그램이 같은 라이브러리를 공유.
* 업데이트 용이: 라이브러리만 교체하면 재컴파일 없이 기능 수정 가능
* 실행 파일 크기 감소.

### 단점
* 배포 시 .dll 또는 .so 파일이 함께 있어야 한다. (의존성 관리 필요)
* 버전 충돌(DLL Hell) 문제 발생 가능.
* 실행 시점에 로드하므로 약간의 성능 오버헤드.

# 3. 정적 라이브러리 예제 (C++)

### 3-1. 정적 라이브러리 생성
```c++
// mathlib.h
# pragma once

int add(int a, int b);
int sub(int a, int b);

// mathlib.cpp
#include "mathlib.h"
int add(int a, int b) { return a + b; } 
int sub(int a, int b) { return a - b; }
```
코드 작성 후 빌드 -> libmathlib.a(Linux) 또는 mathlib.lib (Windows) 생성.

### 3-2. 정적 라이브러리 사용
```c++
// main.cpp

#include<iostream>
#include"mathlib.h"

int main() {
  std::cout << add(3, 4) << std::endl;
  std::cout << sub(3, 4) << std::endl;
}
```
코드 작성 후 빌드 -> 실행 파일은 라이브러리 코드를 내부에 포함.

# 4. 동적 라이브러리 예제 (C++)
### 4-1. 동적 라이브러리 생성
```c++
// mathdll.h
#pragma once

#ifdef MATHDLL_EXPORTS
#define MATHDLL_API __declspec(dllexport)
#else
#define MATHDLL_API __declspec(dllimport)
#endif

extern "C" {
  MATHDLL_API int add(int a, int b);
  MATHDLL_API int sub(int a, int b);
}

// mathdll.cpp
#define MATHDLL_EXPORTS
#include "mathdll.h"

int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
```
빌드하면 아래와 같이 생성된다.<br/>
* mathdll.dll (실제 라이브러리)
* mathdll.lib (링크용 import library)
* mathdll.exp (심볼 정보)

### 4-2. 동적 라이브러리 사용
```c++
// main.cpp
#include<iostream>
#include"mathdll.h"

int main() {
  std::cout << add(3, 4) << std::endl;
  std::cout << sub(3, 4) << std::endl;
}
```
빌드하면 실행 파일 생성<br/>
프로그램 실행 -> mathdll.dll 로드

# 5. 동적 라이브러리 메모리 공유 개념
운영체제는 DLL을 한 번만 메모리에 로드하고 그 라이브러리를 사용하는 모든 프로세스가 같은 코드 메모리(텍스트 섹션)를 공유한다.
* 단, 데이터 영역(전역 변수 등)은 각 프로세스 별로 독립 복사본을 가진다.
* 따라서 여러 프로그램이 같은 DLL을 쓸 때 코드 메모리는 공유하지만, 각 프로그램의 데이터 상태는 서로 영향을 주지 않는다.

### Windows에서 DLL 로드 확인
#### 방법 1. 작업 관리자
작업 관리자 -> 세부 정보 -> 프로그램 우클릭 -> 분석 덤프
#### 방법 2. 명령줄 도구
tasklist /m
```
// 현재 어떤 프로세스가 해당 DLL을 사용하는지 표시된다.
tasklist /m mathdll.dll
```
