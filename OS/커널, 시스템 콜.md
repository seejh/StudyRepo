# 커널
하드웨어와 사용자 프로그램 사이에 있는 프로그램.

### 1. 커널의 주요 역할
* 프로세스 관리 (Process Scheduling)
* 메모리 관리 (Memory Management)
* 입출력(I/O) 관리 (Keyboard, Mouse, Disk, Network)
* 파일 시스템 관리

### 2. 커널이 실행되는 과정
전원 ON -> 부트로더 -> 커널 로드
1. 사용자가 PC 전원을 킨다.
2. BIOS/UEFI가 실행된다.
3. 부트로더 (예: GRUB, Windows Boot Manager)가 커널 파일을 읽어온다.
4. 커널을 메모리에 올리고 실행한다.

// 커널에 대한 설명의 장소
시스템 콜로 연결되는것이 필요.

# 시스템 콜

```c++
코드 예제 사용 필요
```


### 1. CPU가 시스템 콜 명령을 수행하면
#### 1-1) CPU 권한 레벨 변경: Ring3 - > Ring0
유저 모드는 Ring 3, 커널 모드는 Ring 0.<br/>
시스템 콜 명령은 이 권한 레벨을 변경한다.
#### 1-2) 커널 스택으로 전환
스레드는 2개의 자기만의 스택을 가지고 있다. (커널 스택, 유저 스택)<br/>
시스템 콜이 발생하면
* 유저 스택 -> 커널 스택 교체
* 중요 레지스터 저장
등을 수행한다.<br/>

#### 1-3) 커널에 미리 지정된 엔트리 포인트로 점프
커널은 부팅될 때
* 시스템 콜 엔트리(시작 주소)
* 커널 스택 주소
* 필요한 세그먼트 셀렉터
를 CPU 레지스터에 등록해둔다.<br/>
예: Linux x86-64에서는 IA32_LSTAR 레지스터에 시스템 콜 진입 주소를 넣어둔다.

#### 1-4) 커널의 시스템 콜 핸들러가 실행됨.
리눅스의 경우 entry_SYSCALL_64(), 윈도우의 경우 KiSystemCall64(). <br/>
이런 엔트리 함수에서
* 시스템 콜 번호 읽기
* 인자 유효성 검사
* 올바른 커널 함수 호출
같은 작업을 한다.

#### 1-5) 시스템 콜 디스패치
시스템 콜 번호에 따라 커널 함수가 선택된다.
```c++
// 예: 리눅스
sys_read()
sys_write()
sys_open()

// 예: 윈도우
NtCreateFile()
NtReadFile()
```

#### 1-6) 작업 완료 후 커널이 유저 모드로 복귀
sysret 또는 sysexit 명령으로
* 커널 스택 -> 유저 스택 복귀
* Ring0 -> Ring3로 권한 낮춤
* 유저 프로그램으로 돌아감

#### 1-7) 전체 흐름
```
유저 프로그램 calls write() -> libc wrapper -> 레지스터에 인자 넣음 -> syscall 명령 실행
------------------------------------------------------------------------------------
->
CPU가 커널 모드로 전환
커널 스택으로 교체
시스템 콜 엔트리로 점프
------------------------------------------------------------------------------------
->
커널 시스템 콜 핸들러 실행 -> 커널 내부 기능 수행 -> 결과 레지스터에 저장
------------------------------------------------------------------------------------
->
CPU가 유저 모드로 복귀
```

출처 : <br/>
https://sysenter.tistory.com/entry/SYSENTER <br/>

