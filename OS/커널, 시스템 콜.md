
# 커널 모드 vs 유저 모드
CPU는 두 가지 모드를 갖는다. 
유저 모드 - 일반 프로그램 실행, 시스템 자원 접근 불가
커널 모드 - 커널 코드 실행, 시스템 자원 접근 가능

유저 모드 프로그램은 시스템 자원에 접근하지 못함.

그럼 유저 프로


# 시스템 콜
유저 프로그램에서 작업하다가 시스템 자원에 접근할 필요가 있을 때 모드를 바꿔서 커널에 진입하는 것.



### 1. 시스템 콜 상세
#### 1-1) CPU 권한 레벨 변경
Ring3(유저 모드) -> Ring0(커널 모드)로 권한 레벨 변경

#### 1-2) 커널 스택으로 전환
유저 스택 -> 커널 스택 교체 <br/>

* 모든 유저 스레드는 유저 스택, 커널 스택을 가지고 있다.
* 유저 모드일 때는 유저 스택 사용, 커널 모드일 때는 커널 스택 사용.

#### 1-3) 커널에 미리 지정된 엔트리 포인트로 점프
#### 1-4) 커널의 시스템 콜 핸들러 실행
* Linux: entry_SYSCALL_64()
* Windows: KiSystemCall64()
  
위와 같은 엔트리 함수에서 아래와 같은 작업을 수행한다.
* 시스템 콜 번호 읽기
* 인자 유효성 검사
* 올바른 커널 함수 호출

#### 1-5) 시스템 콜 디스패치
시스템 콜 번호에 따라 커널 함수가 선택된다. <br/>
이 함수들이 실제로 하드웨어와 드라이버를 호출하여 일을 처리한다.
* Linux 예: sys_read(), sys_write(), sys_open() 등
* Windows 예: NtCreateFile(), NtReadFile() 등

#### 1-6) 작업 완료 후 커널이 유저 모드로 복귀
sysret 또는 sysexit 명령으로 유저 모드로 돌아간다.
* 커널 스택 -> 유저 스택
* Ring0 -> Ring3

#### 실제 예: OpenProcess()
```
-유저 레벨

Kernel32!OpenProcess ->
ntdll!ZwOpenProcess ->
ntdll!KiFastSystemCall -> // 시스템 콜로 커널 진입
--------------------------------------------------
-커널 레벨

nt!KiFastCallEntry ->
nt!NtOpenProcess
```



출처 : <br/>
https://sysenter.tistory.com/entry/SYSENTER <br/>
