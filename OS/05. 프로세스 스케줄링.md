# 스케줄링
성능 향상<br/>

단일프로세서 시스템에서는 한 번에 한 프로세스만 실행될 수 있다.<br/>
하지만 프로세스가 항상 cpu를 사용하는 것은 아니다. 키보드, 마우스 같은 입출력 장치들의 입력, 출력을 할 때 cpu는 일을 하지 않고 가만히 
있는다. 일반적으로 프로세스는 cpu를 한차례 사용(cpu burst)하고 i/o를 한차례 사용(i/o burst)하는 주기를 반복한다. i/o를 사용하는
주기에서 cpu를 사용하지 않는다는 점을 고려하여 여러 프로세스를 처리할 때 한 프로세스가 모든 작업을 처리하고 난 후 다음 프로세스를 실행하는
방법보다 한 프로세스를 실행 가능한 지점까지 실행하고 i/o 등 cpu를 사용하지 않는 작업을 할 때는 다른 프로세스를 실행한다면 cpu 사용 효율을
높일 수 있다.<br/>

위의 아이디어로 나온 것이 프로세스 스케줄링이다. 

## 프로세스 상태(Process State)
프로세스는 5가지 상태가 있다.<br/>

* **생성(create, new)**
  * 프로세스가 생성되는 중
* **실행(running)**
  * 프로세스가 프로세서를 차지하여 명령어들이 실행되는 중
* **준비(ready, runnable)**
  * cpu만 할당되면 실행 가능한 상태로 cpu 할당을 대기하는 중
* **대기(waiting, blocked)**
  * 프로세스가 i/o 완료, 시그널 수신 등 어떤 사건을 기다리고 있는 상태
* **종료(terminate)**
  * 프로세스의 실행 종료

아래는 프로세스의 상태전이이다.<br/>

* **디스패치(Dispatch)**
  * 프로세스가 ready->running
* **타이머 런아웃(Timer Runout)**
  * 프로세스가 running->ready, 일반적으로 선점 스케줄링에서 발생.
* **블록(Block)**
  * 프로세스가 자원 부족, i/o 대기, 인터럽트 등에 의해 running->waiting
* **활성화(Wake-up)**
  * waiting->ready

CPU가 한 프로세스를 처리하다가 다른 프로세스로 전환하면서 컨텍스트 스위칭이 발생한다. 프로세스가 사용하는 레지스터 등
여러 자원들을 메인 메모리에 저장하고 다음 프로세스가 사용하는 자원들을 메인 메모리에서 가져온다. 문맥교환은 전환시간이 

## 스케줄링 알고리즘
아래는 운영체제가 다음번 실행될 프로세스를 정할 때 대체적으로 기준이 되는 항목들이다.<br/>

* 처리량(Throughput)
* 응답시간(Response Time)
* 반환시간(Turnaround Time)
* 대기시간(waiting Time)
* 자원활용률
* 등등...

## 스케줄링 구분
* **장기(Long-term)** 스케줄링
  * 커널에 새 프로세스 등록
  * new->ready

* **중기(Mid-term)** 스케줄링
  * 메모리 할당 결정
  * suspended<->ready, block

* **단기(Short-term)** 스케줄링
  * CPU 할당 결정
  * running<->ready<->blocked

### 스케줄링 예제
```
프로세스A read() 호출

단기 스케줄러
A Running->Blocked
I/O요청 전달
B Ready->Running

I/O
I/O 요청을 Wait Queue에 추가

I/O 스케줄러
Wait Queue에서 처리 순서 결정(A 결정)
디스크 컨트롤러에 명령

디스크 컨트롤러
실제 I/O 작업 수행
완료 시 인터럽트 발생

인터럽트 핸들러
I/O 완료 확인
```

선점 (Preemptive):

CPU를 강제로 뺏을 수 있음
응답성 좋음, 오버헤드 높음

비선점 (Non-preemptive):

CPU를 자발적으로 반납할 때까지 대기
오버헤드 적음, 응답성 낮음

우선순위 (Priority):

프로세스마다 중요도 부여
선점/비선점 모두 가능
기아 현상 주의 (Aging으로 해결)
