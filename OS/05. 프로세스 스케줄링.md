# 프로세스 스케줄링
* 현재 PC는 다중 프로그래밍 환경(프로세스 여러 개 존재) ->
* 많은 프로세스가 자원을 나눠서 사용해야 한다. (= 스케줄링 필요)

<br/><br/>
## 자원 관리법 (시간, 공간)
### 시간 분할 (Time Sharing)
여러 스레드가 번갈아 가며 사용. (= cpu 자원)

### 공간 분할 (Space Sharing)
분할하여 동시에 사용. (= 메모리 자원)

<br/><br/>
## 스케줄링 목적
시스템 성능 향상 (performance).<br/>

### 시스템 성능 지표
* 응답 시간 (response time): 작업요청(submission)으로부터 응답을 받을 때까지의 시간.
* 작업 처리량 (throughput): 단위 시간 동안 완료된 작업의 수.
* 자원 활용도 (resource utilization): 주어진 시간(Tc) 동안 자원이 활용된 시간(Tr).
  utilization = Tr/Tc.

<br/><br/>
## 대기 시간, 응답 시간, 반환 시간
<img width="646" height="321" alt="image" src="https://github.com/user-attachments/assets/533e5783-9413-4bfe-8e22-cce328fc08a3" /><br/>
대충 용어 알아놓기.<br/>

<br/><br/>
## 스케줄링 기준
스케줄러가 고민하는 요소들.<br/>
* 프로세스 특성: I/O bounded or CPU bounded
* 시스템 특성: Batch or Interactive
* 프로세스 긴급성: 
* 프로세스 우선순위
* 프로세스 총 실행 시간

<br/><br/>
## CPU burst vs I/O burst
프로세스 수행 = CPU 사용 + I/O 대기.<br/>
CPU burst = CPU 사용 시간.<br/>
I/O burst = I/O 대기 시간.<br/>
```
// 프로세서 busrt
load store
add store
read from file

// 입출력 burst

// 프로세서 burst
....
```

CPU bounded: CPU burst가 많으면<br/>
I/O bounded: I/O burst가 많으면<br/>

<br/><br/>
## 스케줄링 단계
발생하는 "빈도" 및 할당 자원에 따른 구분.<br/>
long-term, mid-term, short-term.<br/>

### Long-term Scheduling
<img width="295" height="108" alt="image" src="https://github.com/user-attachments/assets/c48dafc0-c231-438b-9866-21cfc646cb62" /><br/>
JobScheduling이 여기에 속한다.<br/>
JobScheduling=커널에 등록하여 프로세스로 만들 작업을 결정.<br/>
다중 프로그래밍의 정도를 조절(시스템 내에 프로세스 수)하는 역할을 하고
시분할 시스템에서는 모든 작업을 시스템에 등록하기 때문에 이 스케줄링은 불필요하다.

### Mid-term Scheduling
<img width="215" height="230" alt="image" src="https://github.com/user-attachments/assets/71cf9691-ac0f-4ef0-8802-82d5029ad915" /><br/>
Long-term 보다는 자주 일어난다.<br/>
메모리 할당 결정(Memory Allocation)<br/>
Swapping (swap-in/swap-out) <br/>

suspended에서 메모리 할당을 기다리고 있는 프로세스들 중에 누구에게 메모리를 할당할지 결정.<br/>

### Short-term Scheduling
<img width="288" height="180" alt="image" src="https://github.com/user-attachments/assets/17d6b096-585b-4431-b8e7-2d8f383cd7d6" /><br/>
=프로세스 스케줄링(CPU를 할당할 프로세스 결정)<br/>
가장 빈번하게 발생, 고로 매우 빨라야 한다.<br/>
Interrupt, block(I/O), time-out, Etc...<br/>

예를 들어..<br/>
average CPU burst = 100ms => 평균 cpu 실행 시간<br/>
scheduling decision = 10ms => 프로세스 스케줄링 시간<br/>
10/110 => 9% => 9%는 수행을 위한 작업 비용(오버헤드).<br/>

<img width="703" height="402" alt="image" src="https://github.com/user-attachments/assets/43e0b398-141e-464c-a56f-41acf8496c84" />

<br/><br/>
## 스케줄링 정책
선점(Preemptive), 비선점(Non-preemptive)
우선순위(Priority)

### 비선점(Non-preemptive) 스케줄링
비선점 -> 선점(빼앗을) 불가 -> 할당 받으면 끝까지 사용 후 스스로 반납.<br/>
=> 할당 받은 자원을 스스로 반납할 때까지 사용.<br/>

예) system call, I/O, Etc..<br/>

장: 컨텍스트 스위치 오버헤드가 적다.<br/>
단: 잦은 우선순위 역전, 평균 응답 시간 증가<br/>

### 선점(Preemptive) 스케줄링
선점 -> 선점(빼앗을) 가능 -> 남이 할당 받았더라도 빼앗을 수 있다.<br/>
=> 타인에 의해 자원을 빼앗길 수 있다.<br/>

예) 할당 시간 종료 후 우선 순위가 높은 프로세스가 등장한 경우<br/>

장:컨텍스트 스위치 오버헤드가 크다.<br/>




