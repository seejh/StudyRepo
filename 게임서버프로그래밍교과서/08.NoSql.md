
# 8.1 RDBMS와 NoSQL
앞서 알아본 DB는 관계형 데이터베이스(RDBMS)라고 한다. RDBMS는 테이블과 외래 키 등을 사용하고 다양한 종류의 질의 구문으로 원하는 정보를 다각적으로
빠르게 추출할 수 있다. 또 RDBMS는 데이터의 일관성을 중요하게 생각한다. NoSQL은 RDBMS의 이런 특성들을 포기하는 대신 다른 측면의 장점을 가질 수 있는
DB이다. <br/>

RDBMS를 사용하며 아쉬워지는 상황을 예제로 살펴보며 NoSQL의 이점을 알아보자. <br/>
한 테이블에 저장된 레코드들은 모두 같은 형태의 필드를 가져야 한다. 플레이어가 아이템을 구매한 로그를 담는 테이블을 생각해보자.
테이블 정의는 아래와 같다.
* 획득한 시간
* 플레이어ID
* 획득한 아이템 종류

이러한 형태로 현재 DB 테이블에 레코드가 약 1억 개 쌓여있다. 그런데 게임을 유지 보수하다 보니 여기에 다음 필드를 추가해야 하는 상황이 되었다.
* 구매 개수

구매 개수라는 필드를 추가하면 기존에 쌓여 있던 레코드 1억 개에도 구매 개수라는 필드를 반드시 추가해야 한다. 한 테이블의 모든 레코드는 필드 구성이
모두 같아야 하기 때문이다. 필드는 null 값을 가질 수 있기에 기존 레코드에는 새로 추가된 필드 값이 모두 null로 처리할 수 있다. <br/>

그런데 다시 게임을 유지 보수하다 보니 플레이어ID 대신 플레이어의 email 주소를 저장해야 하고 지금까지는 아이템 종류만 로그로 남겼는데 이제 아이템
이름까지 문자열 형태로 남겨야 하는 상황이 되었다. 이렇게 되면 점점 테이블의 구조는 복잡해지고 괴상해진다. 기존 테이블의 필드 구조를 바꾸는 것은 
우리 인간에게도 힘들지만 DB 입장에서도 많은 양의 처리를 단시간에 해야 하는 어려운 일이다. 위의 상황에서 필드 하나를 추가하면 DB 엔진은 기존에 있는
레코드 1억 개 전체에 필드를 추가해야 한다. 그 필드가 null을 갖고 있더라도 말이다. 이때 DB 엔진은 장시간 가동을 멈춘다. 하지만 게임 서비스가 계속
가용되어야 하는 상황이라면 이것은 문제가 된다. 또 프로그램 구조가 복잡해질수록 테이블 구조도 변경해야 한다. 유지 보수하면서 점점 힘들어진다. <br/>

앞에서 플레이어 데이터 트리 전체를 JSON 문서 형태로 만든 후 이를 테이블 필드 하나에 모두 저장하는 방법도 보여줬었는데 관계형 DB에서 이렇게 사용하는 것은
일반적인 사용법이 아니다. RDBMS에서 레코드 1개는 논리적으로 볼 때 리스트나 배열 구조의 데이터이다. 이 레코드가 리스트나 배열이 아닌 트리나 구조체 형태를 갖출
수 있다면 어떨까? NoSQL은 이를 보여준다.

<hr/><br/><br/>

# 일단 패스

<hr/><br/><br/>

# 몽고DB (MongoDB)
NoSQL DB 소프트웨어 종류는 여러가지가 있는데 그 중에서 몽고DB로 알아본다. 몽고DB는 JSON을 사용하기 때문에 JSON에 대해서 알고 있어야 하며 여기서 설명은
생략한다. 몽고DB에서 다루는 데이터의 집합 관계는 RDBMS의 집합 관계와 비슷하지만 몇 가지 차이가 있다.
* RDBMS에서 DB 인스턴스라고 부르는 것은 몽고DB에서도 똑같이 부른다.
* RDBMS의 DB 인스턴스 안에는 테이블이 있다. 몽고DB의 DB 인스턴스 안에는 컬렉션(Collection)이 있다.
* RDBMS의 테이블 안에는 레코드가 있다. 몽고DB에서는 컬렉션 안에 레코드 대신 다큐먼트(Document)가 들어간다.

이 다큐먼트에는 데이터 트리를 저장한다. 추가적으로 몽고DB도 Robo 3T라고 하는 GUI 도구가 있다.

<hr/><br/><br/>

단일 서버를 구현하려면 결국 DB가 병목 지점이 된다. -> DB를 분산할 수 밖에 없다. 
유저 단위로 DB를 수평분할하면 성능과 용량 문제는 해결되지만
유저간 거래가 있는 게임의 DB를 수평분할하려면 여러 유저에 걸치는 트랜잭션을 구현해야 한다.
RDBMS와 Redis를 가지고 분산 DB 트랜잭션을 구현했는지 설명한다.

분산 트랜잭션 (=xa 트랜잭션)



이거를 배현직이랑 엮어 보자
결국 핵심은 이거임 DB를 하나만 쓸 수 없다. DB의 속도가 게임 서버보다 느리기에
DB를 여러대 두고 샤딩해서 써야 한다. 이러면 성능이 해결된다. 
이거를 하는 구성이 RDBMS NoSQL이다.

최대한 축약해서 키워드만 대려가보자
DB 샤딩 필요 => 일관성, 원자성 문제 처리 필요 -> 




