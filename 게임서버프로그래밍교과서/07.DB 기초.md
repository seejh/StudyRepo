
# 7.1 ~ 4 DB 시작
DB는 레코드의 집합인 테이블, 테이블의 집합인 데이터베이스 인스턴스가 있다. <br/>
데이터베이스 인스턴스는 데이터베이스가 다루는 가장 큰 단위의 데이터 집합이다. <br/>
각 데이터베이스 인스턴스 안에는 테이블이 1개 이상 들어간다. 당연히 행과 열(필드)이 있다. <br/>
필드는 이름 말고도 타입이라는 것을 추가로 가지고 있다. 타입은 다음과 같다. <br/>
## 테이블에 사용할 수 있는 필드 종류
<table>
  <th>종류</th>
  <th>설명</th>
  <th>특징</th>
  <th>예시</th>
  <tr>
    <td>int</td>
    <td>정수</td>
    <td>-</td>
    <td>345</td>
  </tr>
  <tr>
    <td>flaot</td>
    <td>부동소수점</td>
    <td>-</td>
    <td>123.45</td>
  </tr>
  <tr>
    <td>char(n)</td>
    <td>길이 n 문자열</td>
    <td>입력한 문자열이 짧으면 뒤에 빈칸이 강제로 채워짐</td>
    <td>"a    "</td>
  </tr>
  <tr>
    <td>varchar(n)</td>
    <td>최대 길이 n의 문자열</td>
    <td>-</td>
    <td>"a"</td>
  </tr>
  <tr>
    <td>nvarchar, nchar</td>
    <td>n이 붙으면 유니코드</td>
    <td>UTF-16</td>
    <td>"こんにちは안녕"</td>
  </tr>
  <tr>
    <td>text</td>
    <td>길이 무제한 문자열</td>
    <td>읽기/쓰기 속도가 느림</td>
    <td>-</td>
  </tr>
  <tr>
    <td>binary</td>
    <td>길이 무제한 바이너리</td>
    <td>상동</td>
    <td>11 22 3F 4B BA 00 CB</td>
  </tr>
  <tr>
    <td>unique identifier</td>
    <td>GUID 또는 UUID</td>
    <td>MySQL에서는 사용 불가</td>
    <td>{58269115-1FDC-4617-BC0F-7F782197270F}</td>
  </tr>
</table>
추가 내용 : 필드에 NULL을 저장할 수도 있다. NULL은 0이나 ""가 아니라 값이 존재하지 않는다는 것이다. <br/>

## SQL
### DML (Data Manipulation Language) - 데이터 조작 언어 
데이터베이스에 "저장된 데이터"를 조회, 삽입, 수정, 삭제하는 명령 <br/>
즉, 사용자가 데이터를 조작하는 기능 담당 <br/>
SELECT, INSERT, UPDATE, DELETE <br/>

### DDL (Data Definition Language) - 데이터 정의 언어
데이터베이스의 "구조"(테이블, 뷰, 인덱스 등)를 생성, 수정, 삭제하는 명령 <br/>
즉, 데이터 저장 구조 정의 <br/>
CREATE, ALTER, DROP, TRUNCATE

추가적으로 DML의 경우 트랜잭션, 롤백 등을 지원하지만 DDL은 그런 거 없다. <br/>

# 인덱스와 키
어떤 두꺼운 도서가 있을 때 거기서 내가 원하는 용어가 나오는 페이지를 찾으려면 어떻게 해야 할까 <br/>
인덱스를 조회해야할 것이다. DB의 인덱스도 이러한 개념이며 아래는 인덱스의 장점(사용 이유)이다. <br/>
## 1) 빠른 검색
인덱스는 필드 단위로 설정할 수 있으며 설정해 놓으면 특정 조건에서 빠른 속도로 원하는 레코드를 찾을 수 있다. <br/>
그 효율은 사용 안함일 때 O(n), 사용할 때 O(log(n))의 차이로, 예를 들어 레코드가 1억 개라면 <br/>
인덱스 사용 안함 = 1억 번, 인덱스 사용 = 12번 가량의 차이가 난다. <br/>
## 2) 중복 방지
인덱스는 빠른 검색 용도 뿐만 아니라, 중복된 값을 방지하는 용도로도 사용된다. <br/>
인덱스에는 유니크(unique)라는 속성을 추가로 지정할 수 있고 지정 시, 해당 필드는 중복이 불가능하게 된다. <br/>
## 3) 정렬
인덱스는 레코드를 정렬하는 용도로도 사용할 수 있다. 인덱스가 없다면 정렬하는 데 많은 시간이 소요된다. <br/>
예를 들어 table1의 필드 a값을 기준으로 정렬된 레코드 목록을 얻고 싶을 때, table1의 필드 a에 대한 인덱스를 추가해 놓으면 된다. <br/>

## 계속해서...
인덱스는 테이블 하나에 여러 개 들어갈 수 있다. <br/>
정리를 하자면 인덱스는 인덱스를 걸어놓은 필드를 기준으로 정렬을 해놓기 때문에 검색할 때 빠른 것이며 <br/>
인덱스를 사용하는 필드의 변동 시에 인덱스도 같이 업데이트 되어야 하기에 없을 때 보다 더 많은 시간이 걸린다. <br/>
따라서 필요하지 않은 인덱스는 가급적 걸지 않는 것이 좋다. <br/>
DB에는 인덱스 중에 기본키(Primary Key)가 있다. 기본키는 특수한 형식의 인덱스로 아래의 성질이 있다. <br/>
1) 한 테이블에 하나만 추가할 수 있다.
2) 필드값의 중복과 NULL을 허용하지 않는다.


## 인덱스 생성 (SQL)
```sql
// table1의 필드 a에 대한 인덱스 생성
CREATE INDEX table1_index ON table1(a ASC)
```

# 




중간 출처 : <br/>
https://honeyjuny.tistory.com/entry/SQL%EC%9D%98-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90%EC%9D%B8-DML%EA%B3%BC-DDL%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90 <br/>
<hr/>
