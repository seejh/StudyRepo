
# 7.1(~4) DB 시작
DB는 레코드의 집합인 테이블, 테이블의 집합인 데이터베이스 인스턴스가 있다. <br/>
데이터베이스 인스턴스는 데이터베이스가 다루는 가장 큰 단위의 데이터 집합이다. <br/>
각 데이터베이스 인스턴스 안에는 테이블이 1개 이상 들어간다. 당연히 행과 열(필드)이 있다. <br/>
필드는 이름 말고도 타입이라는 것을 추가로 가지고 있다. 타입은 다음과 같다. <br/>
## 테이블에 사용할 수 있는 필드 종류
<table>
  <th>종류</th>
  <th>설명</th>
  <th>특징</th>
  <th>예시</th>
  <tr>
    <td>int</td>
    <td>정수</td>
    <td>-</td>
    <td>345</td>
  </tr>
  <tr>
    <td>flaot</td>
    <td>부동소수점</td>
    <td>-</td>
    <td>123.45</td>
  </tr>
  <tr>
    <td>char(n)</td>
    <td>길이 n 문자열</td>
    <td>입력한 문자열이 짧으면 뒤에 빈칸이 강제로 채워짐</td>
    <td>"a    "</td>
  </tr>
  <tr>
    <td>varchar(n)</td>
    <td>최대 길이 n의 문자열</td>
    <td>-</td>
    <td>"a"</td>
  </tr>
  <tr>
    <td>nvarchar, nchar</td>
    <td>n이 붙으면 유니코드</td>
    <td>UTF-16</td>
    <td>"こんにちは안녕"</td>
  </tr>
  <tr>
    <td>text</td>
    <td>길이 무제한 문자열</td>
    <td>읽기/쓰기 속도가 느림</td>
    <td>-</td>
  </tr>
  <tr>
    <td>binary</td>
    <td>길이 무제한 바이너리</td>
    <td>상동</td>
    <td>11 22 3F 4B BA 00 CB</td>
  </tr>
  <tr>
    <td>unique identifier</td>
    <td>GUID 또는 UUID</td>
    <td>MySQL에서는 사용 불가</td>
    <td>{58269115-1FDC-4617-BC0F-7F782197270F}</td>
  </tr>
</table>
추가 내용 : 필드에 NULL을 저장할 수도 있다. NULL은 0이나 ""가 아니라 값이 존재하지 않는다는 것이다. <br/>

## SQL
### DML (Data Manipulation Language) - 데이터 조작 언어 
데이터베이스에 "저장된 데이터"를 조회, 삽입, 수정, 삭제하는 명령 <br/>
즉, 사용자가 데이터를 조작하는 기능 담당 <br/>
SELECT, INSERT, UPDATE, DELETE <br/>

### DDL (Data Definition Language) - 데이터 정의 언어
데이터베이스의 "구조"(테이블, 뷰, 인덱스 등)를 생성, 수정, 삭제하는 명령 <br/>
즉, 데이터 저장 구조 정의 <br/>
CREATE, ALTER, DROP, TRUNCATE

추가적으로 DML의 경우 트랜잭션, 롤백 등을 지원하지만 DDL은 그런 거 없다. <br/>

# 인덱스와 키
어떤 두꺼운 도서가 있을 때 거기서 내가 원하는 용어가 나오는 페이지를 찾으려면 어떻게 해야 할까 <br/>
인덱스를 조회해야할 것이다. DB의 인덱스도 이러한 개념이며 아래는 인덱스의 장점(사용 이유)이다. <br/>
## 1) 빠른 검색
인덱스는 필드 단위로 설정할 수 있으며 설정해 놓으면 특정 조건에서 빠른 속도로 원하는 레코드를 찾을 수 있다. <br/>
그 효율은 사용 안함일 때 O(n), 사용할 때 O(log(n))의 차이로, 예를 들어 레코드가 1억 개라면 <br/>
인덱스 사용 안함 = 1억 번, 인덱스 사용 = 12번 가량의 차이가 난다. <br/>
## 2) 중복 방지
인덱스는 빠른 검색 용도 뿐만 아니라, 중복된 값을 방지하는 용도로도 사용된다. <br/>
인덱스에는 유니크(unique)라는 속성을 추가로 지정할 수 있고 지정 시, 해당 필드는 중복이 불가능하게 된다. <br/>
## 3) 정렬
인덱스는 레코드를 정렬하는 용도로도 사용할 수 있다. 인덱스가 없다면 정렬하는 데 많은 시간이 소요된다. <br/>
예를 들어 table1의 필드 a값을 기준으로 정렬된 레코드 목록을 얻고 싶을 때, table1의 필드 a에 대한 인덱스를 추가해 놓으면 된다. <br/>

## 계속해서...
인덱스는 테이블 하나에 여러 개 들어갈 수 있다. <br/>
정리를 하자면 인덱스는 인덱스를 걸어놓은 필드를 기준으로 정렬을 해놓기 때문에 검색할 때 빠른 것이며 <br/>
인덱스를 사용하는 필드의 변동 시에 인덱스도 같이 업데이트 되어야 하기에 없을 때 보다 더 많은 시간이 걸린다. <br/>
따라서 필요하지 않은 인덱스는 가급적 걸지 않는 것이 좋다. <br/>
DB에는 인덱스 중에 기본키(Primary Key)가 있다. 기본키는 특수한 형식의 인덱스로 아래의 성질이 있다. <br/>
1) 한 테이블에 하나만 추가할 수 있다.
2) 필드값의 중복과 NULL을 허용하지 않는다.

## 인덱스 생성 (SQL)
```sql
// table1의 필드 a에 대한 인덱스 생성
CREATE INDEX table1_index ON table1(a ASC)
```

DDL, DML 출처 : <br/>
https://honeyjuny.tistory.com/entry/SQL%EC%9D%98-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90%EC%9D%B8-DML%EA%B3%BC-DDL%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90 <br/>
<hr/><br/><br/>

# 7.7 플레이어 정보를 DB에 저장하는 방법
플레이어 데이터는 구조체와 목록의 집합 형태로 되어 있는 데이터 덩어리이며 이러한 데이터는 트리 형태로 표현할 수 있다. <br/>
트리 형태로 표현하면 아래와 같다. <br/>
![image](https://github.com/user-attachments/assets/af398886-490a-44d1-9f68-e4f60e74a7de) <br/>
## 이를 테이블에 넣기 위해서는? 
### 1) 플레이어 데이터 전체를 문서 형태로 만들어서 테이블에 넣는다.
플레이어 데이터를 문서 형태로 만들면 JSON 문서 형태로 나온다. JSON 문서는 트리 구조의 데이터를 문자열 형태로 표현하며 <br/>
트리의 각 노드는 속성(이름과 값의 짝)을 여러 개 저장할 수 있다. 예로, 다음과 같다 <br/>
```json
{
  "ID":"Hong Gil Dong",
  "password":"wlknelhklkfhe",
  "Characters": [
    {
      "ID":"My Little Elf",
      "Level":35,
      "Items": [
        {
          "Type":123,
          "Amount":1
        }
      ]
    },
    "ID":"My Big Orc"
    "Level":23,
    "Items":[]
  ]
}
```
플레이어 정보를 위의 JSON 형태로 하나로 만든 후 테이블에 저장한다. 플레이어ID와 JSON 텍스트 필드면 된다. <br/>
<table>
  <th>ID</th><th>문서</th>
  <tr>
    <td>Hong Gil Dong</td>
    <td>
      {"ID":"Hong Gil Dong", "password":"wlknelhklkfhe", "Characters": [{
      "ID":"My Little Elf","Level":35,"Items": [{"Type":123,"Amount":1}]},
      "ID":"My Big Orc""Level":23,"Items":[]]}
    </td>
  </tr>
  <tr>
    <td>Kang Bu Ja</td>
    <td>....</td>
  </tr>
</table>
JSON을 담을 필드를 varchar로 하는 것은 적합하지 않다. JSON 문자열이 얼마나 길어질지 모르기 때문에 문자열 제한이 없는 text 필드를 사용한다. <br/>
JSON 대신 XML 형식을 사용해도 된다. XML도 JSON과 마찬가지로 트리 노드와 각 노드의 속성을 저장하는 것이 가능하다. <br/>
둘 중에 본인이 편한것을, DB가 지원하는 것을 사용하면 되며 둘 다 없다면 text를 사용하면 된다. <br/>

### 2) 플레이어 데이터를 구성하는 트리 노드 각각을 테이블에 넣는다.
앞의 1)번 방식으로 JSON이나 XML로 플레이어 정보를 저장하는 방식은 이해하기 쉽지만 원하는 조건 값을 찾는 등 실사용하기에는 쉽지 않다. <br/>
그래서 2)번 방식, 플레이어 정보를 여러 테이블에 나눠 저장하는 방법을 써야한다. <br/>
트리의 각 노드는 속성(이름, 값 짝)을 여러 개 가지고 있다. 따라서 각 노드는 레코드로 저장되어야 한다. <br/>

#### 2-1) UserAccount 테이블 
<table>
  <th>ID</th><th>Password</th><th>ETC</th>
  <tr>
    <td>Hong Gil Dong</td><td>...</td><td>...</td>
  </tr>
  <tr>
    <td>Kang Bu Ja</td><td>...</td><td>...</td>
  </tr>
</table>
가장 기본이 되는 테이블부터 생성해본다. 플레이어 각각에 대한 정보를 저장하는 테이블로서 UserAccount 테이블을 만든다. <br/>
이때 플레이어 ID는 서로 중복되지 않아야 한다. 따라서 ID 필드는 유니크 속성이 들어있는 인덱스로 설정하거나 기본키 설정을 해야 한다. <br/>

#### 2-2) Character 테이블
DB에 어떤 테이블을 넣어야 할지 계획을 잡을 때 자주 사용하는 방식은 외래 키(Foreign Key)를 사용하는 것이다. <br/>
외래 키란 현재 테이블의 어떤 필드가 다른 테이블의 특정 필드를 가리키는 것을 의미한다. <br/>
플레이어는 한 계정에 여러 개의 플레이어 캐릭터를 가지고 있고, 반대로 말하면 플레이어 캐릭터는 본인이 소유하는 플레이어가 있음을 의미한다. <br/>
플레이어 캐릭터를 테이블에 저장할 때 플레이어 캐릭터의 고유 이름으로 ID 뿐만 아니라 "이 플레이어가 누구의 소유인가?"도 저장하면 어떨까? <br/>
위의 말을 쉽게 표현하자면 "관계"가 있는 테이블이 생길 때 외래 키를 사용해서 표현한다. <br/>
<table>
  <th>ID</th><th>OwnerUserAccountID</th><th>ETC</th>
  <tr>
    <td>My Little Elf</td><td>Hong Gil Dong</td><td>...</td>
  </tr>
  <tr>
    <td>My Big Orc</td><td>Hong Gil Dong</td><td>...</td>
  </tr>
</table>
이렇게 하면 플레이어 Hong Gil Dong은 플레이어 캐릭터 MyLittleElf, MyBigOrc를 가진다고 표현할 수 있다. <br/>
여기서 OwnerUserAccountID 필드는 플레이어 정보를 담은 UserAccount 테이블의 레코드를 가리켜야 한다. <br/>
플레이어 테이블에서 고윳값이 보장되는 것은 현재 기본키인 ID 필드이며 OwnerUserAccountID 필드는 UserAccount의 ID 필드를 가리켜야 한다. <br/>
이를 OwnerUserAccountID 필드는 UserAccount의 ID 필드를 가리키는 외래키라고 한다. 

<br/><br/>
보통 외래키를 가지고 CRUD를 자주 하기에 외래 키에 인덱스를 설정하는 것이 좋다. 다만, 여기에서는 외래 키가 중복되어야 하므로 논유니크 인덱스(nonunique index)로 설정해야 한다. <br/>

#### 2-3) Item 테이블
플레이어 캐릭터와 아이템 간 "관계"를 보면 플레이어 캐릭터는 아이템을 여러 개 가질 수 있어야 한다. <br/>
역시 반대로 말하면, 아이템을 가리키는 레코드 각각은 자기 자신을 가지고 있는 플레이어 캐릭터를 가리키고 있어야 한다. <br/>
<table>
  <th>ID</th><th>OwnerCharacterID</th><th>ETC</th>
  <tr>
    <td>...</td><td>My Little Elf</td><td>...</td>
  </tr>
  <tr>
    <td>...</td><td>My Little Elf</td><td>...</td>
  </tr>
</table>





<hr/>

$\it{\large{\color{#DD6565}외래키}}$



어떻게 나눠야 하는가?
1. 트리의 각 노드는 테이블의 레코드가 된다.
2. 각 노드의 소유자, 즉 부모 노드는 외래 키가 된다.

위의 표현에 대한 공적인 표현 방법이 필요하다 (개체관계다이어그램(ERDiagram), UML(Unified Modeling Language))

질의 구문 실행




구조체와 목록의 집합 형태 -> 트리 표현 -> ER Diagram으로 표현 -> DB 스키마 생성







