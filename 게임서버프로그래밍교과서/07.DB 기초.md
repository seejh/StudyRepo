
# 7.1(~4) DB 시작
DB는 레코드의 집합인 테이블, 테이블의 집합인 데이터베이스 인스턴스가 있다. <br/>
데이터베이스 인스턴스는 데이터베이스가 다루는 가장 큰 단위의 데이터 집합이다. <br/>
각 데이터베이스 인스턴스 안에는 테이블이 1개 이상 들어간다. 당연히 행과 열(필드)이 있다. <br/>
필드는 이름 말고도 타입이라는 것을 추가로 가지고 있다. 타입은 다음과 같다. <br/>
## 테이블에 사용할 수 있는 필드 종류
<table>
  <th>종류</th>
  <th>설명</th>
  <th>특징</th>
  <th>예시</th>
  <tr>
    <td>int</td>
    <td>정수</td>
    <td>-</td>
    <td>345</td>
  </tr>
  <tr>
    <td>flaot</td>
    <td>부동소수점</td>
    <td>-</td>
    <td>123.45</td>
  </tr>
  <tr>
    <td>char(n)</td>
    <td>길이 n 문자열</td>
    <td>입력한 문자열이 짧으면 뒤에 빈칸이 강제로 채워짐</td>
    <td>"a    "</td>
  </tr>
  <tr>
    <td>varchar(n)</td>
    <td>최대 길이 n의 문자열</td>
    <td>-</td>
    <td>"a"</td>
  </tr>
  <tr>
    <td>nvarchar, nchar</td>
    <td>n이 붙으면 유니코드</td>
    <td>UTF-16</td>
    <td>"こんにちは안녕"</td>
  </tr>
  <tr>
    <td>text</td>
    <td>길이 무제한 문자열</td>
    <td>읽기/쓰기 속도가 느림</td>
    <td>-</td>
  </tr>
  <tr>
    <td>binary</td>
    <td>길이 무제한 바이너리</td>
    <td>상동</td>
    <td>11 22 3F 4B BA 00 CB</td>
  </tr>
  <tr>
    <td>unique identifier</td>
    <td>GUID 또는 UUID</td>
    <td>MySQL에서는 사용 불가</td>
    <td>{58269115-1FDC-4617-BC0F-7F782197270F}</td>
  </tr>
</table>
추가 내용 : 필드에 NULL을 저장할 수도 있다. NULL은 0이나 ""가 아니라 값이 존재하지 않는다는 것이다. <br/>

## SQL
### DML (Data Manipulation Language) - 데이터 조작 언어 
데이터베이스에 "저장된 데이터"를 조회, 삽입, 수정, 삭제하는 명령 <br/>
즉, 사용자가 데이터를 조작하는 기능 담당 <br/>
SELECT, INSERT, UPDATE, DELETE <br/>

### DDL (Data Definition Language) - 데이터 정의 언어
데이터베이스의 "구조"(테이블, 뷰, 인덱스 등)를 생성, 수정, 삭제하는 명령 <br/>
즉, 데이터 저장 구조 정의 <br/>
CREATE, ALTER, DROP, TRUNCATE

추가적으로 DML의 경우 트랜잭션, 롤백 등을 지원하지만 DDL은 그런 거 없다. <br/>

# 인덱스와 키
어떤 두꺼운 도서가 있을 때 거기서 내가 원하는 용어가 나오는 페이지를 찾으려면 어떻게 해야 할까 <br/>
인덱스를 조회해야할 것이다. DB의 인덱스도 이러한 개념이며 아래는 인덱스의 장점(사용 이유)이다. <br/>
## 1) 빠른 검색
인덱스는 필드 단위로 설정할 수 있으며 설정해 놓으면 특정 조건에서 빠른 속도로 원하는 레코드를 찾을 수 있다. <br/>
그 효율은 사용 안함일 때 O(n), 사용할 때 O(log(n))의 차이로, 예를 들어 레코드가 1억 개라면 <br/>
인덱스 사용 안함 = 1억 번, 인덱스 사용 = 12번 가량의 차이가 난다. <br/>
## 2) 중복 방지
인덱스는 빠른 검색 용도 뿐만 아니라, 중복된 값을 방지하는 용도로도 사용된다. <br/>
인덱스에는 유니크(unique)라는 속성을 추가로 지정할 수 있고 지정 시, 해당 필드는 중복이 불가능하게 된다. <br/>
## 3) 정렬
인덱스는 레코드를 정렬하는 용도로도 사용할 수 있다. 인덱스가 없다면 정렬하는 데 많은 시간이 소요된다. <br/>
예를 들어 table1의 필드 a값을 기준으로 정렬된 레코드 목록을 얻고 싶을 때, table1의 필드 a에 대한 인덱스를 추가해 놓으면 된다. <br/>

## 계속해서...
인덱스는 테이블 하나에 여러 개 들어갈 수 있다. <br/>
정리를 하자면 인덱스는 인덱스를 걸어놓은 필드를 기준으로 정렬을 해놓기 때문에 검색할 때 빠른 것이며 <br/>
인덱스를 사용하는 필드의 변동 시에 인덱스도 같이 업데이트 되어야 하기에 없을 때 보다 더 많은 시간이 걸린다. <br/>
따라서 필요하지 않은 인덱스는 가급적 걸지 않는 것이 좋다. <br/>
DB에는 인덱스 중에 기본키(Primary Key)가 있다. 기본키는 특수한 형식의 인덱스로 아래의 성질이 있다. <br/>
1) 한 테이블에 하나만 추가할 수 있다.
2) 필드값의 중복과 NULL을 허용하지 않는다.

## 인덱스 생성 (SQL)
```sql
// table1의 필드 a에 대한 인덱스 생성
CREATE INDEX table1_index ON table1(a ASC)
```

DDL, DML 출처 : <br/>
https://honeyjuny.tistory.com/entry/SQL%EC%9D%98-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90%EC%9D%B8-DML%EA%B3%BC-DDL%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90 <br/>
<hr/><br/><br/>

# 7.7 플레이어 정보를 DB에 저장하는 방법
플레이어 데이터는 구조체와 목록의 집합이라 할 수 있다. 구조체형 데이터를 테이블에 저장하는 법을 알아본다. <br/>
구조체와 목록의 집합 형태로 되어 있는 데이터 덩어리는 아래와 같이 트리 형태로 표현할 수 있다. <br/>
![image](https://github.com/user-attachments/assets/af398886-490a-44d1-9f68-e4f60e74a7de) <br/>
이를 DB에 저장하려면 2가지 방법이 있다. <br/>
## 1) 플레이어 데이터 전체를 문서 형태로 만들어서 테이블에 넣는다.
플레이어 데이터를 문서 형태로 만들면 JSON 문서 형태로 나온다. JSON 문서는 트리 구조의 데이터를 문자열 형태로 표현하며 <br/>
트리의 각 노드는 속성(이름과 값의 짝)을 여러 개 저장할 수 있다. <br/>
쉽게 말해 데이터 구조를 JSON으로 표현하고 필드 하나에 저장한다는 것으로 아래와 같다. <br/>
```json
{
  "ID":"Hong Gil Dong",
  "password":"wlknelhklkfhe",
  "Characters": [
    {
      "ID":"My Little Elf",
      "Level":35,
      "Items": [
        {
          "Type":123,
          "Amount":1
        }
      ]
    },
    "ID":"My Big Orc"
    "Level":23,
    "Items":[]
  ]
}
```
위처럼 JSON 형태로 구조를 표현한 후 DB에 저장한다. 플레이어ID와 JSON 텍스트 필드면 되면 된다. <br/>
<table>
  <th>ID</th><th>문서</th>
  <tr>
    <td>Hong Gil Dong</td>
    <td>
      {"ID":"Hong Gil Dong", "password":"wlknelhklkfhe", "Characters": [{
      "ID":"My Little Elf","Level":35,"Items": [{"Type":123,"Amount":1}]},
      "ID":"My Big Orc""Level":23,"Items":[]]}
    </td>
  </tr>
  <tr>
    <td>Kang Bu Ja</td>
    <td>....</td>
  </tr>
</table>
JSON을 담을 필드를 varchar로 하는 것은 적합하지 않다. JSON 문자열이 얼마나 길어질지 모르기 때문에 문자열 제한이 없는 text 필드를 사용한다. <br/>
JSON 대신 XML 형식을 사용해도 되며 둘 다 사용하기가 여의치 않다면 text를 사용하면 된다. <br/>

## 2) 플레이어 데이터를 구성하는 트리 노드 각각을 테이블에 넣는다.
앞의 1)번 방식으로 JSON이나 XML로 플레이어 정보를 저장하는 방식은 이해하기 쉽지만 원하는 조건 값을 찾는 등 실사용하기에는 쉽지 않다. <br/>
플레이어 정보를 여러 테이블에 나눠서 저장해보자 <br/>
트리의 각 노드는 속성(이름과 값의 짝)을 여러 개 가지고 있다. 따라서 각 노드는 데이터베이스의 레코드로 저장되어야 한다. <br/>
일단 만들면서 학습해보자. <br/>

### UserAccount 테이블 
<table>
  <th>ID</th><th>Password</th><th>ETC</th>
  <tr>
    <td>Hong Gil Dong</td><td>...</td><td>...</td>
  </tr>
  <tr>
    <td>Kang Bu Ja</td><td>...</td><td>...</td>
  </tr>
</table>
플레이어 각각에 대한 정보를 저장하는 테이블 <br/>
플레이어 ID는 중복되지 않아야 한다. 따라서 ID 필드에는 유니크 속성이 있는 인덱스를 쓰거나 기본키 설정을 해야 한다. <br/>

### Character 테이블
<table>
  <th>ID</th><th>OwnerUserAccountID</th><th>ETC</th>
  <tr>
    <td>My Little Elf</td><td>Hong Gil Dong</td><td>...</td>
  </tr>
  <tr>
    <td>My Big Orc</td><td>Hong Gil Dong</td><td>...</td>
  </tr>
</table>
플레이어는 플레이어 캐릭터를 여러 개 가지고 있다. 반대로 말하면 플레이어 캐릭터는 각각 자기를 소유하고 있는 플레이어가 있음을 의미하며 <br/>
DB에서는 이를 "관계"라하며 외래 키(Foreign Key)를 사용해서 표현한다. <br/>
추가로 말하자면, 외래 키를 갖고 CRUD를 자주 하다고 한다. 따라서 외래 키에 대해 인덱스를 설정하는 것이 좋다. <br/>
외래 키는 중복을 허용하므로 NonUnique Index로 설정해야 한다. <br/>

##### 외래 키?
현재 테이블의 어떤 필드가 다른 테이블의 특정 필드(기본키)를 참조하는 것을 의미 <br/>
중복이 허용된다. <br/>

### Item 테이블
<table>
  <th>ID</th><th>OwnerCharacterID</th><th>ETC</th>
  <tr>
    <td>...</td><td>My Little Elf</td><td>...</td>
  </tr>
  <tr>
    <td>...</td><td>My Little Elf</td><td>...</td>
  </tr>
</table>
플레이어 캐릭터와 아이템 간 상관관계도 살펴본다. 플레이어 캐릭터는 아이템을 여러 개 가질 수 있어야 한다. <br/>
역시 반대로 말하면 아이템은 자기를 소유하는 플레이어 캐릭터를 가리켜야 한다 <br/>
OwnerCharacterID라는 필드를 추가하고 이 필드는 Character 테이블의 ID를 가리키는 외래 키가 되게 한다. <br/>

## 정리
플레이어 데이터는 구조체와 목록의 집합으로 트리 형태로 표현할 수 있고 트리 형태로 표현한 것을 아래의 방법을 통해 DB에 저장할 수 있다. <br/>
* 트리의 각 노드는 테이블의 레코드가 된다.
* 각 노드의 소유자, 즉 부모 노드는 외래 키가 된다.
이 방법으로 DB를 만들면 아래와 같은 형태로 나온다. <br/>
![image](https://github.com/user-attachments/assets/a212b53d-26b3-44bb-83da-40f80b404e86) <br/>
Hong Gil dong과 그것이 소유한 My Little Elf, Big Orc라는 두 캐릭터, My Little Elf가 갖고 있는 아이템 1, 아이템 2를 표현하고 있다 <br/>

DB 구조를 표현할 때는 여러 사람이 쉽게 작업할 수 있도록 어떤 공인된 표현법이 있어야 한다. 보통 개체-관계 다이어그램(ER Diagram)이나 <br/>
UML(Unified Modeling Language, 통합 모델링 언어)를 많이 사용한다. ER Diagram으로 위의 그림을 표현하면 아래와 같다. <br/>
![image](https://github.com/user-attachments/assets/fb668a9e-f300-46cb-b4c1-bd6c814cd6a8) <br/>
ER Diagram에 대한 설명 추가 필요 <br/>

<hr/><br/><br/>

# 7.9 질의 구문 실행
DB 설계를 했으니 DB를 사용(질의 구문 CRUD 실행)해본다. 그 전에 DB를 사용한다는 것은 DB에 질의 구문을 던지고 받는 행위를 계속한다는 것이고 <br/>
DB에 질의 구문을 자주 던지는 것은 비효율적이라는 것을 알아야 한다. 그 이유는 아래와 같다. <br/>
![image](https://github.com/user-attachments/assets/d08e5498-fbab-4575-addf-cc1875fc14b9) <br/>
* 질의 구문 던지기 후 결과 받기 과정이 수행되는 동안 디바이스 타임(Device Time)이 발생한다.
* 게임 서버와 DB 간 네트워크 레이턴시를 다 모으면 꽤 긴 시간이다.
같은 결과를 내는 행위를 하는데 쿼리의 횟수를 조절할 수 있으면 쿼리 횟수를 줄이는 것이 좋다는 말 <br/>

## 저장 프로시저
DB는 질의 구문을 받으면 이를 처리할 수 있는 준비 작업 연산을 한다. DB 엔진이 받은 질의 구문을 분석 후 계획을 하는 것인데 문제는 <br/>
이 짓을 쿼리를 받을 때 마다 한다는 것이고, 이를 "처음 한 번만 분석한 뒤 나머지는 그냥 쓰면 안되나" 하는 개념이 저장 프로시저이다. <br/>
저장 프로시저는 실행 계획 준비 작업이 완료된 상태로 DB에 저장이 되고 이후 사용시에 분석은 패스한다. <br/>
## 트랜잭션


DB는 질의 구문을 받으면 이를 처리할 수 있는 준비 작업 연산을 한다. 데이터 베이스 엔진이 받은 질의 구문을 분석하고 무슨 일을 해야할 지 계획을 하는 것인데
문제는 이 짓을 받을 때 마다 한다. 처음 한 번만 이 일을 하고 이후부터는 생략할 수 있으면 좋을 것이다. 
이를 위한 것이 저장 프로시저이다.
DB 측에 미리 질의 구문 집합을 저장해두는 것이다. 





<hr/><br/><br/>
$\it{\large{\color{#DD6565}외래키}}$









