
# 7.1(~4) DB 시작
DB는 레코드의 집합인 테이블, 테이블의 집합인 데이터베이스 인스턴스가 있다. <br/>
데이터베이스 인스턴스는 데이터베이스가 다루는 가장 큰 단위의 데이터 집합이다. <br/>
각 데이터베이스 인스턴스 안에는 테이블이 1개 이상 들어간다. 당연히 행과 열(필드)이 있다. <br/>
필드는 이름 말고도 타입이라는 것을 추가로 가지고 있다. 타입은 다음과 같다. <br/>
## 테이블에 사용할 수 있는 필드 종류
<table>
  <th>종류</th>
  <th>설명</th>
  <th>특징</th>
  <th>예시</th>
  <tr>
    <td>int</td>
    <td>정수</td>
    <td>-</td>
    <td>345</td>
  </tr>
  <tr>
    <td>flaot</td>
    <td>부동소수점</td>
    <td>-</td>
    <td>123.45</td>
  </tr>
  <tr>
    <td>char(n)</td>
    <td>길이 n 문자열</td>
    <td>입력한 문자열이 짧으면 뒤에 빈칸이 강제로 채워짐</td>
    <td>"a    "</td>
  </tr>
  <tr>
    <td>varchar(n)</td>
    <td>최대 길이 n의 문자열</td>
    <td>-</td>
    <td>"a"</td>
  </tr>
  <tr>
    <td>nvarchar, nchar</td>
    <td>n이 붙으면 유니코드</td>
    <td>UTF-16</td>
    <td>"こんにちは안녕"</td>
  </tr>
  <tr>
    <td>text</td>
    <td>길이 무제한 문자열</td>
    <td>읽기/쓰기 속도가 느림</td>
    <td>-</td>
  </tr>
  <tr>
    <td>binary</td>
    <td>길이 무제한 바이너리</td>
    <td>상동</td>
    <td>11 22 3F 4B BA 00 CB</td>
  </tr>
  <tr>
    <td>unique identifier</td>
    <td>GUID 또는 UUID</td>
    <td>MySQL에서는 사용 불가</td>
    <td>{58269115-1FDC-4617-BC0F-7F782197270F}</td>
  </tr>
</table>
추가 내용 : 필드에 NULL을 저장할 수도 있다. NULL은 0이나 ""가 아니라 값이 존재하지 않는다는 것이다. <br/>

## SQL
### DML (Data Manipulation Language) - 데이터 조작 언어 
데이터베이스에 "저장된 데이터"를 조회, 삽입, 수정, 삭제하는 명령 <br/>
즉, 사용자가 데이터를 조작하는 기능 담당 <br/>
SELECT, INSERT, UPDATE, DELETE <br/>

### DDL (Data Definition Language) - 데이터 정의 언어
데이터베이스의 "구조"(테이블, 뷰, 인덱스 등)를 생성, 수정, 삭제하는 명령 <br/>
즉, 데이터 저장 구조 정의 <br/>
CREATE, ALTER, DROP, TRUNCATE

추가적으로 DML의 경우 트랜잭션, 롤백 등을 지원하지만 DDL은 그런 거 없다. <br/>

# 인덱스와 키
어떤 두꺼운 도서가 있을 때 거기서 내가 원하는 용어가 나오는 페이지를 찾으려면 어떻게 해야 할까 <br/>
인덱스를 조회해야할 것이다. DB의 인덱스도 이러한 개념이며 아래는 인덱스의 장점(사용 이유)이다. <br/>
## 1) 빠른 검색
인덱스는 필드 단위로 설정할 수 있으며 설정해 놓으면 특정 조건에서 빠른 속도로 원하는 레코드를 찾을 수 있다. <br/>
그 효율은 사용 안함일 때 O(n), 사용할 때 O(log(n))의 차이로, 예를 들어 레코드가 1만 개라면 <br/>
인덱스 사용 안함 = 1만 번, 인덱스 사용 = 12번 가량의 차이가 난다. <br/>
## 2) 중복 방지
인덱스는 빠른 검색 용도 뿐만 아니라, 중복된 값을 방지하는 용도로도 사용된다. <br/>
인덱스에는 유니크(unique)라는 속성을 추가로 지정할 수 있고 지정 시, 해당 필드는 중복이 불가능하게 된다. <br/>
## 3) 정렬
인덱스는 레코드를 정렬하는 용도로도 사용할 수 있다. 인덱스가 없다면 정렬하는 데 많은 시간이 소요된다. <br/>
예를 들어 table1의 필드 a값을 기준으로 정렬된 레코드 목록을 얻고 싶을 때, table1의 필드 a에 대한 인덱스를 추가해 놓으면 된다. <br/>

## 계속해서...
인덱스는 테이블 하나에 여러 개 들어갈 수 있다. <br/>
정리를 하자면 인덱스는 인덱스를 걸어놓은 필드를 기준으로 정렬을 해놓기 때문에 검색할 때 빠른 것이며 <br/>
인덱스를 사용하는 필드의 변동 시에 인덱스도 같이 업데이트 되어야 하기에 없을 때 보다 더 많은 시간이 걸린다. <br/>
따라서 필요하지 않은 인덱스는 가급적 걸지 않는 것이 좋다. <br/>
DB에는 인덱스 중에 기본키(Primary Key)가 있다. 기본키는 특수한 형식의 인덱스로 아래의 성질이 있다. <br/>
1) 한 테이블에 하나만 추가할 수 있다.
2) 필드값의 중복과 NULL을 허용하지 않는다.

## 인덱스 생성 (SQL)
```sql
// table1의 필드 a에 대한 인덱스 생성
CREATE INDEX table1_index ON table1(a ASC)
```

DDL, DML 출처 : <br/>
https://honeyjuny.tistory.com/entry/SQL%EC%9D%98-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90%EC%9D%B8-DML%EA%B3%BC-DDL%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90 <br/>
<hr/><br/><br/>

# 7.7 DB 설계 (플레이어 정보를 DB에 저장하는 방법)
플레이어 데이터는 구조체와 목록의 집합이라 할 수 있다. 구조체와 목록의 집합 형태로 되어 있는 데이터 덩어리는 아래와 같이 트리 형태로 표현할 수 있다. <br/>
![image](https://github.com/user-attachments/assets/af398886-490a-44d1-9f68-e4f60e74a7de) <br/>
이를 DB에 저장하려면 2가지 방법이 있다.
## 1) 플레이어 데이터 전체를 문서 형태로 만들어서 테이블에 넣는다.
플레이어 데이터를 문서 형태로 만들면 JSON 문서 형태로 나온다. JSON 문서는 트리 구조의 데이터를 문자열 형태로 표현하며
트리의 각 노드는 속성(이름과 값의 짝)을 여러 개 저장할 수 있다. <br/>
쉽게 말해 데이터 구조를 JSON으로 표현하고 필드 하나에 저장한다는 것으로 방법은 아래와 같다. <br/>
```json
{
  "ID":"Hong Gil Dong",
  "password":"wlknelhklkfhe",
  "Characters": [
    {
      "ID":"My Little Elf",
      "Level":35,
      "Items": [
        {
          "Type":123,
          "Amount":1
        }
      ]
    },
    "ID":"My Big Orc"
    "Level":23,
    "Items":[]
  ]
}
```
위처럼 JSON 형태로 구조를 표현한 후 한 줄로 만들어 DB에 저장한다. 플레이어ID와 JSON 텍스트 필드면 되면 된다. <br/>
<table>
  <th>ID</th><th>문서</th>
  <tr>
    <td>Hong Gil Dong</td>
    <td>
      {"ID":"Hong Gil Dong", "password":"wlknelhklkfhe", "Characters": [{
      "ID":"My Little Elf","Level":35,"Items": [{"Type":123,"Amount":1}]},
      "ID":"My Big Orc""Level":23,"Items":[]]}
    </td>
  </tr>
  <tr>
    <td>Kang Bu Ja</td>
    <td>....</td>
  </tr>
</table>
JSON을 담을 필드는 문자열 계통 필드인데 varchar과 같은 길이가 정해져 있는 필드보다는 제한이 없는 text 필드를 사용한다.
JSON 대신 XML을 사용해도 되며 둘 다 사용하기가 여의치 않으면 text를 사용한다. 

## 2) 플레이어 데이터를 구성하는 트리 노드 각각을 테이블에 넣는다.
앞의 1)번 방식으로 JSON이나 XML로 플레이어 정보를 한 필드에 욱여 넣는 방식은 이해와 사용이 쉽지만 저장된 플레이어 정보에서 
원하는 조건 값을 찾는 등 실사용하기에는 한계가 있을 수 있다. 그렇다면 플레이어 정보를 여러 테이블에 나눠 저장해야 한다.
방법을 알아보자. 트리의 각 노드는 속성(이름과 값의 짝)을 여러 개 가지고 있다. 따라서 각 노드는 데이터베이스의 레코드로 저장되어야 한다.

### UserAccount 테이블 
<table>
  <th>ID</th><th>Password</th><th>ETC</th>
  <tr>
    <td>Hong Gil Dong</td><td>...</td><td>...</td>
  </tr>
  <tr>
    <td>Kang Bu Ja</td><td>...</td><td>...</td>
  </tr>
</table>
플레이어 각각에 대한 정보를 저장하는 테이블로서 플레이어 ID는 중복되지 않아야 한다. <br/>
따라서 ID 필드에는 유니크 속성이 있는 인덱스를 쓰거나 기본키 설정을 해야 한다. <br/>

### Character 테이블
<table>
  <th>ID</th><th>OwnerUserAccountID</th><th>ETC</th>
  <tr>
    <td>My Little Elf</td><td>Hong Gil Dong</td><td>...</td>
  </tr>
  <tr>
    <td>My Big Orc</td><td>Hong Gil Dong</td><td>...</td>
  </tr>
</table>
플레이어가 소유하고 있는 플레이어 캐릭터를 나타내며 플레이어는 플레이어 캐릭터를 여러 개 가지고 있다. 
반대로 말하면 플레이어 캐릭터는 각각 자기를 소유하고 있는 플레이어가 있음을 의미하며 
DB에서는 이를 "관계"라하며 외래 키(Foreign Key)를 사용해서 표현한다. DB에 테이블을 설계할 때 이러한 "관계"를 생각해야 하고 관계는 
외래 키(Foreign Key)를 사용하여 표현한다. 외래 키란 테이블의 어떤 필드가 다른 테이블의 특정 필드 값을 참조하는 것을 의미한다.
또한, 외래 키를 가지고 CRUD를 자주 하기에 외래 키에 대해 인덱스 설정을 하는 것이 성능상 좋고 다만 외래 키는 중복을 허용해야 하기에 
논유니크 인덱스(NonUnique Index)로 설정해야 한다.

### Item 테이블
<table>
  <th>ID</th><th>OwnerCharacterID</th><th>ETC</th>
  <tr>
    <td>...</td><td>My Little Elf</td><td>...</td>
  </tr>
  <tr>
    <td>...</td><td>My Little Elf</td><td>...</td>
  </tr>
</table>
플레이어 캐릭터가 소유하고 있는 아이템을 나타내는 테이블이며 플레이어 캐릭터는 아이템을 여러 개 가질 수 있어야 한다. 
역시 반대로 말하면 아이템은 자기를 소유하는 플레이어 캐릭터를 가리켜야 한다.
OwnerCharacterID라는 필드를 추가하고 Character 테이블의 ID를 참조하는 외래 키로 설정한다.

## 정리
### DB 설계
플레이어 데이터는 구조체와 목록의 집합으로 트리 형태로 표현할 수 있고 트리 형태로 표현한 것을 아래 내용을 통해 DB 설계한다.
* 트리의 각 노드는 테이블의 레코드가 된다.
* 각 노드의 소유자, 즉 부모 노드는 외래 키가 된다.
이 방법으로 DB 테이블을 설계하면 아래와 같은 형태로 나온다. <br/>
![image](https://github.com/user-attachments/assets/a212b53d-26b3-44bb-83da-40f80b404e86) <br/>
Hong Gil dong과 그것이 소유한 My Little Elf, Big Orc라는 두 캐릭터, My Little Elf가 갖고 있는 아이템 1, 아이템 2를 표현하고 있다 <br/>

### 설계된 DB 구조 표현
이러한 DB 구조를 여러 사람이 이해할 수 있는 공인된 표현법이 있어야 한다. 보통 ER Diagram(개체-관계 다이어그램)이나 
UML(Unified Modeling Language, 통합 모델링 언어)를 많이 사용하고 ER Diagram으로 위의 그림을 표현하면 아래와 같다.
![image](https://github.com/user-attachments/assets/fb668a9e-f300-46cb-b4c1-bd6c814cd6a8) <br/>
ER Diagram에 대한 양식은 여기서는 생략

<hr/><br/><br/>

# 7.9 질의 구문 실행
앞 파트에서 DB 설계를 했으니 여기서는 DB를 사용하는 방법과 필요한 지식들이 나오는데 사용하는 방법(기본 CRUD)은 패스한다.
DB를 사용한다는 것은 DB에 질의 구문을 던지고 받는 행위를 계속한다는 것이고 DB에 질의 구문을 자주 던지는 것은 
비효율적이라는 것을 알아야 한다. 그 이유는 아래와 같다.
![image](https://github.com/user-attachments/assets/d08e5498-fbab-4575-addf-cc1875fc14b9) <br/>
* 질의 구문을 던지고 결과를 받기 위해 기다리는 디바이스 타임(Device Time)이 발생한다.
* 게임 서버와 DB 간 네트워크 레이턴시를 다 모으면 꽤 긴 시간이다.

쿼리를 할 때 마다 위의 시간 낭비가 생길 수 밖에 없으므로 같은 값에 쿼리를 하는 행위를 줄일 수 있으면 줄이는 것이 좋다. 

## 저장 프로시저
DB 엔진은 질의 구문을 받으면 질의 구문을 분석, 계획한 뒤 실행을 한다. 문제는 이 행위를 쿼리를 받을 때 마다 하기에 이 부분이 성능 저하를 일으킨다.
그래서 이를 "처음 한 번만 분석한 뒤 나머지는 그냥 쓰면 안되나"하는 부분을 해결해 주는 것이 저장 프로시저이다.
저장 프로시저는 처음에 DB에 쿼리를 저장하고 저장할 때 분석과 계획을 완료하고 이후 사용에 대해 분석 및 계획 없이 실행만 한다.

## 트랜잭션
트랜잭션을 설명할 때 자주 나오는 예로 은행 계좌 이체 프로그램을 많이 든다. 아래는 Hong Gil Dong이 Kang Bu Ja에게 100원을 이체하려는 상황이다.
```sql
update UserAccount set Money = Money + 100 where ID='Kang Bu Ja'
update UserAccount set Money = Money - 100 where ID='Hong Gil Dong'
```
위의 상황에서 프로그래머의 실수 또는 시스템 결함으로 위의 구문에서 하나만 실행된다면 문제가 크다. DB에서 이러한 상황을 막을 수 있는 방어기제가 있다.
그것이 지금 설명하는 트랜잭션이다. 트랜잭션은 "구문이 모두 실행되던지, 아예 하나도 실행되지 않던지" 이 둘 중 하나의 결과를 보장한다.
```sql
begin transaction
update UserAccount set Money=Money+100 where ID='Kang Bu Ja'
update UserAcocunt set Money=Money-100 where ID='Hong Gil Dong'
commit
```
DB 종류에 따라 사용법이 다르기에 위에서 기본 흐름만 본다. begin transaction으로 트랜잭션 구간이 시작되며 구간 내의 구문을 실행하고
결과가 만족스러우면 commit, 그렇지 않으면 rollback을 한다.

### 트랜잭션 = DB의 뮤텍스
트랜잭션은 게임 서버의 뮤텍스와 비슷하다. db에 질의 구문을 하는 주체를 db세션이라고 한다. 이 db세션이 2개 이상이라고 해보자.
db세션1이 트랜잭션을 걸고 액세스하고 있을 때 db세션2가 해당 레코드에 액세스하면 어떻게 될까?
그리고 db세션1이 데이터를 변경하다가 rollback 해버리면 어떻게 될까? 이를 실험하는 방법은 아래와 같다.
```sql
// DB Session 1
begin transaction
update UserAccount set Money=Money+100 ....
update UserAccount set Money=Money-100 .....

// DB Session 2
select Money from UserAccount where ID='Kang Bu Ja'
```
db세션1에서 begin transaction 후 두 update 구문을 실행한다. 이후 db세션2에서 select 구문을 실행하면 실행결과가 나오지 않고 무한 대기 상태가 된다.
db세션2에서 접근하려는 데이터가 다른 세션(db세션1)에서 트랜잭션(락)을 걸고 점유하고 있어서 접근할 수 없기 때문이며 현재 트랜잭션을 걸고 있는
db세션1에서 commit이나 rollback을 하고 트랜잭션을 끝내야 db세션2에서 액세스할 수 있다. 이 기다리는 시간이 길면 timeout이 발생한다.
* 트랜잭션을 걸고 액세스하는 레코드는 멀티스레드 프로그래밍에서 뮤텍스를 잠금한 것과 비슷하다
* 트랜잭션을 걸고 액세스하는 레코드는 다른 질의 구문 세션에서 액세스하면 앞선 트랜잭션이 완료되거나 취소될 때 까지 블로킹이 걸린다.

### 데드락
뮤텍스를 사용할 때는 데드락을 조심해야 하고 DB 트랜잭션에서도 마찬가지다.
레코드 A, B가 있을 때 db세션1에서는 레코드 A->B 순으로 접근하는데 A에 락을 걸고 B에 락을 건다. db세션2에서는 레코드 B->A 순으로 접근하는데
B에 락을 걸고 A에 락을 건다. 이 두 질의 구문이 동시에 실행되면 어떻게 될까? 아래는 이것을 도식화한 것이다.
1. db세션1 : 레코드 A 락 
2. db세션2 : 레코드 B 락 
3. db세션1 : 레코드 B -> 대기 발생 
4. db세션2 : 레코드 A -> 대기 발생 

안타깝게도 데드락이 발생한다. 멀티스레드 프로그래밍과 차이점이 있다면 두 질의 구문 프로세스 중 하나는 몇 분간 대기하다가 오류를 출력한다는 것이다 <br/>
그러면 질의 구문을 할 때 레코드 접근 순서를 A->B 순서로 갈 수 있게한다면? 레코드 A, B를 액세스할 때 프라이머리 키 순서대로 액세스하면 이론적으로는 교착 
상태가 생기지 않지만 질의 구문을 다루다 보면 사실 그럴 여력이 없다. 트랜잭션을 사용한다는 것 자체가 웬만큼 복잡한 처리를 한다는 의미이기 때문이다.

### 성능 하락
트랜잭션이 관여되는 레코드는 다른 질의 구문 프로세스에서 액세스할 경우 블로킹을 일으켜 병렬 처리 효율성이 떨어진다. 여기서 잠금되는 영역은 관련 레코드만 잠금되는 것이 아니라
그 레코드 주변에 있는 다른 레코드 및 해당 레코드가 있는 테이블 전체가 잠금되기도 한다. <br/>

따라서 DB 트랜잭션을 걸 때는 꼭 필요한 최소한의 구간에서만 하는 것이 좋다. 트랜잭션의 영향을 받는 레코드의 개수를 최소한으로, 트랜잭션을 시작부터 끝날 때 까지
데이터를 액세스하는 횟수 역시 최소로 하는 것이다.

### 그래서 트랜잭션을 쓰나 마나?

```c++
// 게임 서버 메모리와 DB에서 두 플레이어 간 아이템 교환
void RequestExchangeItem(player1, player2, item1, item2) {
  // 예외 처리 (플레이어가 아이템을 가지고 있는지 확인)
  if (player1.hasItem(item1) == false || player2.hasItem(item2) == false)
    return;

  // 서버 메모리에서 아이템 교환
  player1.removeItem(item1);
  player2.removeItem(item1);
  player1.addItem(item2);
  player2.addItem(item1);

  // DB에서 아이템 교환
  db.execute("update item set owner={player2} where itemid={item1};");
  db.execute("update item set owner={player1} where itemid={item2}");
}
```
게임 서버에서는 서버 메모리에서 먼저 검증을 한 후 DB에 액세스하기 때문에 트랜잭션이 그렇게까지 필요하진 않다. 
DB의 트랜잭션 기능은 주로 논리적 실패(Money가 음수가 된 경우 등) 때문에 롤백할 때 사용하는 것이 대부분이다.
(개인적으로는 시스템 등의 문제가 안 생기는 거라고 해석했다.) <br/>

그러나 게임 서버에서 사전 검증을 마쳤다고 하더라도, 문제가 생길 가능성이 적다고 하더라도 그것이 아예 확률 0이 아니기에
위험성을 생각하지 않을 수가 없다. 결국은 트랜잭션이 필요해 보인다. 그러나 트랜잭션의 사용으로 인한 성능 저하와 데드락 가능성은 
큰 문제다. 이와 같이 트랜잭션을 사용하기 어려운데 데이터의 일관성을 보장할 수 있는 방법은 없는가 <br/>

여러 가지 방법이 있다. 일단 어딘가에 로그를 남겨 놓고 두 플레이어의 레코드를 업데이트 한다. 그 후 업데이트 완료되면 해당 로그를 지워버리는 것.
또 다른 방법으로는 트랜잭션에서 발생하는 잠금 수준을 완화하는 것이다. 트랜잭션의 잠금 수준을 "현재 트랜잭션을 걸고 접근하고 있는 데이터에 대해 다른 곳에서도
읽을 수 있게 허락한다"라고 변경하는 것이다. 그러나 이렇게 하면 DB의 ACID 특징을 다소 위반하게 된다. <br/>

* 게임 서버가 플레이어 정보를 메모리에 항상 보관한다.
* 플레이어 처리의 주체는 게임 서버 메모리 안에서 이루어진다.
* 데이터베이스는 세이브 데이터 역할 정도만 한다.

필자는 위와 같은 상황에서 트랜잭션 사용으로 얻는 원자성 효과보다 교착 상태나 병렬성 하락으로 일어나는 손실이 더 크다고 한다.

<hr/><br/><br/>

# 7.11 보안을 위한 주의 사항
DB는 해커가 노리는 주요 대상이다. 따라서 DB를 안전하게 보호하려는 노력이 필요하다. 게임 서버에서는 DB에 접속할 때 접속 가능한 계정으로만 접속하게 하는 것이 좋다.
다음 두 가지를 기억하라 <br/>
* DB의 모든 것을 다룰 수 있는 관리자 계정은 오직 관리자만 직접 다룰 수 있게 한다.
* 게임 서버가 사용하는 계정은 게임 서버가 다루는 테이블 이외에는 건드리지 못하게 한다.

또 DB는 게임 서버 이외의 다른 곳에서는 접속하지 못하게 네트워크를 격리할 필요가 있다. 사설 네트워크를 구축하거나 방화벽을 이용하여 게임 서버만 접속할 수 있는 것도 괜찮다.<br/><br/>

게임 서버가 DB에 질의 구문을 던질 때, 질의 구문을 해커가 조작할 수 잇는 상황을 미리 고려해야 한다. 아래는 그 예제이다. <br/>
```c++
/*-------------------------------------------------------------------------
  우리의 게임 서버에서 DB 작업을 하는 코드
  userName에는 게임 사용자가 입력한 문자열이 서버에서 수신한 그대로 들어간다.
-------------------------------------------------------------------------*/
sprintf(queryString, "select * from t1 where a='%s'", userName);
db.execute(queryString);

/*-------------------------------------------------------------------------
  위의 상황에서 게임 사용자가 해커고, 그 해커가 userName에 고의적으로 다음 내용을 보낸다면
-------------------------------------------------------------------------*/
'; delete from table1; select * from table1 where a='

/*-------------------------------------------------------------------------
  DB가 받는 완성된 쿼리는 아래와 같다.
  table1의 모든 레코드가 삭제된다.
-------------------------------------------------------------------------*/
select * from t1 where a=''; delete from table1; select * from table1 where a=''
```
이러한 공격을 질의 구문 인젝션(Query Injection)이라고 한다. 이를 막으려면 애당초 sprint 같은 질의 구문을 사용자 입력 값으로 만들지 말아야 한다.
공격을 막기 위한 용도도 있지만 프로그램을 오래 유지 보수하다 보면 생길 수 있는 관리적인 측면에서의 문제 상황도 방지해준다. 

## 매개변수화된 질의 구문 (Parameterized Query)
이를 방지하기 위해 웬만한 DB 연결 모듈은 매개변수화된 질의 구문(Parameterized Query) 실행 기능을 갖고 있다.
매개변수화된 질의 구문이란 질의 구문 자체에는 우리가 만든 문장만 들어가게 하고, 질의 구문에 들어갈 수 있는 다른 입력 값들은 
별도의 매개변수로 격리해서 입력하는 것을 의미한다. 앞에서 배운 저장 프로시저와 준비된 명령문(Prepared Statement)이 이에 해당한다. <br/><br/>

## 해당 내용 마무리 필요

<hr/><br/><br/>
$\it{\large{\color{#DD6565}외래키}}$









