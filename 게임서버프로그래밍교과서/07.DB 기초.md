
# 7.1(~4) DB 시작
DB는 레코드의 집합인 테이블, 테이블의 집합인 데이터베이스 인스턴스가 있다. <br/>
데이터베이스 인스턴스는 데이터베이스가 다루는 가장 큰 단위의 데이터 집합이다. <br/>
각 데이터베이스 인스턴스 안에는 테이블이 1개 이상 들어간다. 당연히 행과 열(필드)이 있다. <br/>
필드는 이름 말고도 타입이라는 것을 추가로 가지고 있다. 타입은 다음과 같다. <br/>
## 테이블에 사용할 수 있는 필드 종류
<table>
  <th>종류</th>
  <th>설명</th>
  <th>특징</th>
  <th>예시</th>
  <tr>
    <td>int</td>
    <td>정수</td>
    <td>-</td>
    <td>345</td>
  </tr>
  <tr>
    <td>flaot</td>
    <td>부동소수점</td>
    <td>-</td>
    <td>123.45</td>
  </tr>
  <tr>
    <td>char(n)</td>
    <td>길이 n 문자열</td>
    <td>입력한 문자열이 짧으면 뒤에 빈칸이 강제로 채워짐</td>
    <td>"a    "</td>
  </tr>
  <tr>
    <td>varchar(n)</td>
    <td>최대 길이 n의 문자열</td>
    <td>-</td>
    <td>"a"</td>
  </tr>
  <tr>
    <td>nvarchar, nchar</td>
    <td>n이 붙으면 유니코드</td>
    <td>UTF-16</td>
    <td>"こんにちは안녕"</td>
  </tr>
  <tr>
    <td>text</td>
    <td>길이 무제한 문자열</td>
    <td>읽기/쓰기 속도가 느림</td>
    <td>-</td>
  </tr>
  <tr>
    <td>binary</td>
    <td>길이 무제한 바이너리</td>
    <td>상동</td>
    <td>11 22 3F 4B BA 00 CB</td>
  </tr>
  <tr>
    <td>unique identifier</td>
    <td>GUID 또는 UUID</td>
    <td>MySQL에서는 사용 불가</td>
    <td>{58269115-1FDC-4617-BC0F-7F782197270F}</td>
  </tr>
</table>
추가 내용 : 필드에 NULL을 저장할 수도 있다. NULL은 0이나 ""가 아니라 값이 존재하지 않는다는 것이다. <br/>

## SQL
### DML (Data Manipulation Language) - 데이터 조작 언어 
데이터베이스에 "저장된 데이터"를 조회, 삽입, 수정, 삭제하는 명령 <br/>
즉, 사용자가 데이터를 조작하는 기능 담당 <br/>
SELECT, INSERT, UPDATE, DELETE <br/>

### DDL (Data Definition Language) - 데이터 정의 언어
데이터베이스의 "구조"(테이블, 뷰, 인덱스 등)를 생성, 수정, 삭제하는 명령 <br/>
즉, 데이터 저장 구조 정의 <br/>
CREATE, ALTER, DROP, TRUNCATE

추가적으로 DML의 경우 트랜잭션, 롤백 등을 지원하지만 DDL은 그런 거 없다. <br/>

# 인덱스와 키
어떤 두꺼운 도서가 있을 때 거기서 내가 원하는 용어가 나오는 페이지를 찾으려면 어떻게 해야 할까 <br/>
인덱스를 조회해야할 것이다. DB의 인덱스도 이러한 개념이며 아래는 인덱스의 장점(사용 이유)이다. <br/>
## 1) 빠른 검색
인덱스는 필드 단위로 설정할 수 있으며 설정해 놓으면 특정 조건에서 빠른 속도로 원하는 레코드를 찾을 수 있다. <br/>
그 효율은 사용 안함일 때 O(n), 사용할 때 O(log(n))의 차이로, 예를 들어 레코드가 1만 개라면 <br/>
인덱스 사용 안함 = 1만 번, 인덱스 사용 = 12번 가량의 차이가 난다. <br/>
## 2) 중복 방지
인덱스는 빠른 검색 용도 뿐만 아니라, 중복된 값을 방지하는 용도로도 사용된다. <br/>
인덱스에는 유니크(unique)라는 속성을 추가로 지정할 수 있고 지정 시, 해당 필드는 중복이 불가능하게 된다. <br/>
## 3) 정렬
인덱스는 레코드를 정렬하는 용도로도 사용할 수 있다. 인덱스가 없다면 정렬하는 데 많은 시간이 소요된다. <br/>
예를 들어 table1의 필드 a값을 기준으로 정렬된 레코드 목록을 얻고 싶을 때, table1의 필드 a에 대한 인덱스를 추가해 놓으면 된다. <br/>

## 계속해서...
인덱스는 테이블 하나에 여러 개 들어갈 수 있다. <br/>
정리를 하자면 인덱스는 인덱스를 걸어놓은 필드를 기준으로 정렬을 해놓기 때문에 검색할 때 빠른 것이며 <br/>
인덱스를 사용하는 필드의 변동 시에 인덱스도 같이 업데이트 되어야 하기에 없을 때 보다 더 많은 시간이 걸린다. <br/>
따라서 필요하지 않은 인덱스는 가급적 걸지 않는 것이 좋다. <br/>
DB에는 인덱스 중에 기본키(Primary Key)가 있다. 기본키는 특수한 형식의 인덱스로 아래의 성질이 있다. <br/>
1) 한 테이블에 하나만 추가할 수 있다.
2) 필드값의 중복과 NULL을 허용하지 않는다.

## 인덱스 생성 (SQL)
```sql
// table1의 필드 a에 대한 인덱스 생성
CREATE INDEX table1_index ON table1(a ASC)
```

DDL, DML 출처 : <br/>
https://honeyjuny.tistory.com/entry/SQL%EC%9D%98-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90%EC%9D%B8-DML%EA%B3%BC-DDL%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90 <br/>
<hr/><br/><br/>

# 7.7 플레이어 정보를 DB에 저장하는 방법
플레이어 데이터는 구조체와 목록의 집합이라 할 수 있다. 구조체형 데이터를 테이블에 저장하는 법을 알아본다. <br/>
구조체와 목록의 집합 형태로 되어 있는 데이터 덩어리는 아래와 같이 트리 형태로 표현할 수 있다. <br/>
![image](https://github.com/user-attachments/assets/af398886-490a-44d1-9f68-e4f60e74a7de) <br/>
이를 DB에 저장하려면 2가지 방법이 있다. <br/>
## 1) 플레이어 데이터 전체를 문서 형태로 만들어서 테이블에 넣는다.
플레이어 데이터를 문서 형태로 만들면 JSON 문서 형태로 나온다. JSON 문서는 트리 구조의 데이터를 문자열 형태로 표현하며 <br/>
트리의 각 노드는 속성(이름과 값의 짝)을 여러 개 저장할 수 있다. <br/>
쉽게 말해 데이터 구조를 JSON으로 표현하고 필드 하나에 저장한다는 것으로 아래와 같다. <br/>
```json
{
  "ID":"Hong Gil Dong",
  "password":"wlknelhklkfhe",
  "Characters": [
    {
      "ID":"My Little Elf",
      "Level":35,
      "Items": [
        {
          "Type":123,
          "Amount":1
        }
      ]
    },
    "ID":"My Big Orc"
    "Level":23,
    "Items":[]
  ]
}
```
위처럼 JSON 형태로 구조를 표현한 후 DB에 저장한다. 플레이어ID와 JSON 텍스트 필드면 되면 된다. <br/>
<table>
  <th>ID</th><th>문서</th>
  <tr>
    <td>Hong Gil Dong</td>
    <td>
      {"ID":"Hong Gil Dong", "password":"wlknelhklkfhe", "Characters": [{
      "ID":"My Little Elf","Level":35,"Items": [{"Type":123,"Amount":1}]},
      "ID":"My Big Orc""Level":23,"Items":[]]}
    </td>
  </tr>
  <tr>
    <td>Kang Bu Ja</td>
    <td>....</td>
  </tr>
</table>
JSON을 담을 필드를 varchar로 하는 것은 적합하지 않다. JSON 문자열이 얼마나 길어질지 모르기 때문에 문자열 제한이 없는 text 필드를 사용한다. <br/>
JSON 대신 XML 형식을 사용해도 되며 둘 다 사용하기가 여의치 않다면 text를 사용하면 된다. <br/>

## 2) 플레이어 데이터를 구성하는 트리 노드 각각을 테이블에 넣는다.
앞의 1)번 방식으로 JSON이나 XML로 플레이어 정보를 저장하는 방식은 이해하기 쉽지만 원하는 조건 값을 찾는 등 실사용하기에는 쉽지 않다. <br/>
플레이어 정보를 여러 테이블에 나눠서 저장해보자 <br/>
트리의 각 노드는 속성(이름과 값의 짝)을 여러 개 가지고 있다. 따라서 각 노드는 데이터베이스의 레코드로 저장되어야 한다. <br/>
일단 만들면서 학습해보자. <br/>

### UserAccount 테이블 
<table>
  <th>ID</th><th>Password</th><th>ETC</th>
  <tr>
    <td>Hong Gil Dong</td><td>...</td><td>...</td>
  </tr>
  <tr>
    <td>Kang Bu Ja</td><td>...</td><td>...</td>
  </tr>
</table>
플레이어 각각에 대한 정보를 저장하는 테이블 <br/>
플레이어 ID는 중복되지 않아야 한다. 따라서 ID 필드에는 유니크 속성이 있는 인덱스를 쓰거나 기본키 설정을 해야 한다. <br/>

### Character 테이블
<table>
  <th>ID</th><th>OwnerUserAccountID</th><th>ETC</th>
  <tr>
    <td>My Little Elf</td><td>Hong Gil Dong</td><td>...</td>
  </tr>
  <tr>
    <td>My Big Orc</td><td>Hong Gil Dong</td><td>...</td>
  </tr>
</table>
플레이어는 플레이어 캐릭터를 여러 개 가지고 있다. 반대로 말하면 플레이어 캐릭터는 각각 자기를 소유하고 있는 플레이어가 있음을 의미하며 <br/>
DB에서는 이를 "관계"라하며 외래 키(Foreign Key)를 사용해서 표현한다. <br/>
추가로 말하자면, 외래 키를 갖고 CRUD를 자주 하다고 한다. 따라서 외래 키에 대해 인덱스를 설정하는 것이 좋다. <br/>
외래 키는 중복을 허용하므로 NonUnique Index로 설정해야 한다. <br/>

##### 외래 키?
현재 테이블의 어떤 필드가 다른 테이블의 특정 필드(기본키)를 참조하는 것을 의미 <br/>
중복이 허용된다. <br/>

### Item 테이블
<table>
  <th>ID</th><th>OwnerCharacterID</th><th>ETC</th>
  <tr>
    <td>...</td><td>My Little Elf</td><td>...</td>
  </tr>
  <tr>
    <td>...</td><td>My Little Elf</td><td>...</td>
  </tr>
</table>
플레이어 캐릭터와 아이템 간 상관관계도 살펴본다. 플레이어 캐릭터는 아이템을 여러 개 가질 수 있어야 한다. <br/>
역시 반대로 말하면 아이템은 자기를 소유하는 플레이어 캐릭터를 가리켜야 한다 <br/>
OwnerCharacterID라는 필드를 추가하고 이 필드는 Character 테이블의 ID를 가리키는 외래 키가 되게 한다. <br/>

## 정리
플레이어 데이터는 구조체와 목록의 집합으로 트리 형태로 표현할 수 있고 트리 형태로 표현한 것을 아래의 방법을 통해 DB에 저장할 수 있다. <br/>
* 트리의 각 노드는 테이블의 레코드가 된다.
* 각 노드의 소유자, 즉 부모 노드는 외래 키가 된다.
이 방법으로 DB를 만들면 아래와 같은 형태로 나온다. <br/>
![image](https://github.com/user-attachments/assets/a212b53d-26b3-44bb-83da-40f80b404e86) <br/>
Hong Gil dong과 그것이 소유한 My Little Elf, Big Orc라는 두 캐릭터, My Little Elf가 갖고 있는 아이템 1, 아이템 2를 표현하고 있다 <br/>

DB 구조를 표현할 때는 여러 사람이 쉽게 작업할 수 있도록 어떤 공인된 표현법이 있어야 한다. 보통 개체-관계 다이어그램(ER Diagram)이나 <br/>
UML(Unified Modeling Language, 통합 모델링 언어)를 많이 사용한다. ER Diagram으로 위의 그림을 표현하면 아래와 같다. <br/>
![image](https://github.com/user-attachments/assets/fb668a9e-f300-46cb-b4c1-bd6c814cd6a8) <br/>
ER Diagram에 대한 설명 추가 필요 <br/>

<hr/><br/><br/>

# 7.9 질의 구문 실행
DB 설계를 했으니 DB를 사용(질의 구문 CRUD 실행)해본다. DB를 효율적으로 사용하는 방법들을 개념들과 함께 알아본다. <br/>
DB를 사용한다는 것은 DB에 질의 구문을 던지고 받는 행위를 계속한다는 것이고 DB에 질의 구문을 자주 던지는 것은 비효율적이라는 것을 알아야 한다. 그 이유는 아래와 같다. <br/>
![image](https://github.com/user-attachments/assets/d08e5498-fbab-4575-addf-cc1875fc14b9) <br/>
* 질의 구문 던지기 후 결과 받기 과정이 수행되는 동안 디바이스 타임(Device Time)이 발생한다.
* 게임 서버와 DB 간 네트워크 레이턴시를 다 모으면 꽤 긴 시간이다.
  
같은 결과를 내는 행위를 하는데 쿼리의 횟수를 조절할 수 있으면 쿼리 횟수를 줄이는 것이 좋다는 말 <br/>

## 저장 프로시저
DB는 질의 구문을 받으면 이를 처리할 수 있는 준비 작업 연산을 한다. DB 엔진이 받은 질의 구문을 분석 후 계획을 하는 것인데 문제는 <br/>
이 짓을 쿼리를 받을 때 마다 한다는 것이고, 이를 "처음 한 번만 분석한 뒤 나머지는 그냥 쓰면 안되나" 하는 개념이 저장 프로시저이다. <br/>
저장 프로시저는 실행 계획 준비 작업이 완료된 상태로 DB에 저장이 되고 이후 사용시에 분석은 패스한다. <br/>
## 트랜잭션
트랜잭션을 설명할 때 자주 나오는 예로 은행의 계좌 이체 프로그램을 만든다고 가정해보자. <br/>
Hong Gil Dong이 Kang Bu Ja에게 100원을 이체하려면 다음 처리를 해야 한다. <br>
```sql
update UserAccount set Money = Money + 100 where ID='Kang Bu Ja'
update UserAccount set Money = Money - 100 where ID='Hong Gil Dong'
```
프로그래머의 실수 또는 시스템 결함으로 이 구문 중 하나만 실행된다면 끔찍한 일이 될 것이다. <br/>
이 예제는 단순하기에 실수를 일으킬 만한 것이 별로 없어 보이지만, 프로그램이 오랫 동안 유지 보수되고 시스템이 복잡해지면 이러한 일이 발생할 가능성이 높아진다. <br/>
DB에서 이러한 상황을 막을 수 있는 멋진 방어 기제가 있다. 지금 설명하는 "트랜잭션"이다. <br/>
트랜잭션의 기본 개념은 구문이 "모두 실행되던지, 하나도 실행되지 않던지" 둘 중 하나의 결과만 보장되게 하는 것이다. <br/>
```sql
begin transaction
update UserAccount set Money=Money+100 where ID='Kang Bu Ja'
update UserAcocunt set Money=Money-100 where ID='Hong Gil Dong'
commit
```
트랜잭션의 흐름은 다음과 같다. begin transaction으로 트랜잭션 구간이 시작되며 위의 update 2구문을 실행한 후 커밋으로 확정을 낸다. <br/>
만약 구문을 실행하는 중 문제가 생기면 commit 대신 rollback을 실행하여 결과를 모두 되돌린다. <br/>

### 트랜잭션은 뮤텍스와 비슷
상황을 통해 조금 더 자세히 알아보도록 하자. <br/>
게임 서버 1, 2가 있는데 게임 서버 1에서 begin transaction 후 두 update 구문을 실행한다. <br/>
그 후 게임 서버 2에서  같이 게임 서버 1이 액세스한 레코드를 읽는다. <br/>
그런데 게임 서버 1에서 rollback 구문을 실행해 버리면 어떻게 될까? <br/>
이를 테스트하는 방법이 있다. db 세션을 하나 더 추가하여 테스트하면 된다. <br/>
```sql
// DB Session 1
begin transaction
update UserAccount set Money=Money+100 ....
update UserAccount set Money=Money-100 .....

// DB Session 2
select Money from UserAccount where ID='Kang Bu Ja'
```
테스트는 위의 코드에서 DB Session1 코드를 실행한 후 DB Session2에서 코드를 실행하면 되며 아래는 그에 대한 설명이다. <br/>
세션1에서 트랜잭션을 걸고 시작하기는 했지만 아직 트랜잭션을 커밋하거나 롤백하지 않았고 이후 세션2에서 구문을 실행하면 <br/>
실행 결과가 나오지 않고 무한 대기 상태가 될 것이다. Money의 값이 무엇이 될 지 최종 판단을 할 수 없기 때문이다. <br/>
첫 번째 질의 구문 창에서 트랜잭션이 실행 중에 있고 이것이 커밋되느냐 롤백되느냐에 따라 결정된다. <br/>
이제 첫 번째 질의 구문 창에서 다음을 실행해 본다. <br/>
```sql
commit 혹은 rollback
```
이제서야 두 번째 질의 구문 창에서 무한 대기 상태가 끝나고 결과가 나올 것이다. 여기서 우리가 알 수 있는 것은 다음과 같다. <br/>
* 트랜잭션을 걸고 액세스하는 레코드는 멀티스레드 프로그래밍에서 뮤텍스를 잠금한 것과 비슷하다
* 트랜잭션을 걸고 액세스하는 레코드는 다른 질의 구문 세션에서 액세스하면 앞선 트랜잭션이 완료되거나 취소될 때 까지 블로킹이 걸린다.

### 데드락
뮤텍스를 사용할 때는 데드락을 조심해야 하고 DB 트랜잭션에서도 데드락을 주의해야 한다. 이것도 예를 통해 알아본다 <br/>
레코드 A, B가 있을 때 db세션1에서는 레코드 A->B 순으로 접근하는데 A에 락을 걸고 B에 락을 건다. db세션2에서는 레코드 B->A 순으로 접근하는데
B에 락을 걸고 A에 락을 건다. 이 두 질의 구문이 동시에 실행되며 아래와 같은 상황이 발생되면 어떻게 될까? <br/>
1. db세션1 : 레코드 A 락 
2. db세션2 : 레코드 B 락 
3. db세션1 : 레코드 B -> 대기 발생 
4. db세션2 : 레코드 A -> 대기 발생 

안타깝게도 데드락이 발생한다. 멀티스레드 프로그래밍과 차이점이 있다면 두 질의 구문 프로세스 중 하나는 몇 분간 대기하다가 오류를 출력한다는 것이다 <br/>
이때 우리가 할 일은 다음과 같다. <br/>
```
두 질의 구문은 반드시 레코드 A->B 순서로 액세스 한다.
```
그러나 이것이 말처럼 쉽지는 않다. 트랜잭션을 사용한다는 자체가 우리가 의도하는 프로그래밍이 웬만큼 복잡한 처리를 해야 한다는 의미이다.
레코드 A, B를 액세스할 때 프라이머리 키 순서대로 액세스하면 이론적으로는 교착 상태가 생기지 않지만, 질의 구문을 다루다 보면 사실 그럴 여력이 없다
따라서 DB 트랜잭션을 걸 때는 꼭 필요한 최소한의 구간에서만 하는 것이 좋다. 트랜잭션의 영향을 받는 레코드의 개수를 최소한으로, 트랜잭션을 시작부터 끝날 때 까지
데이터를 액세스하는 횟수 역시 최소로 하는 것이다. <br/><br/>

그리고 교착 상태로 질의 구문 실행이 매우 오랫동안 블로킹되거나 실패를 출력할 때도 반드시 별도로 처리해 주어야 한다. 데드락으로 수십초 블로킹을 하면 타임아웃 오류가 발생하는데
예를 들어 질의 구문을 실행한 곳에서 타임아웃 오류가 발생했을 때 질의 구문을 다시 실행한다든지 하는 방법으로 오류를 핸들링 처리하면 된다.<br/><br/>

트랜잭션이 관여되는 레코드는 다른 질의 구문 프로세스에서 액세스할 경우 블로킹을 일으켜 병렬 처리 효율성이 떨어진다. 불행하게도 트랜잭션 관련 레코드만 잠금되는 것이 아니라
그 레코드 주변에 있는 다른 레코드 및 해당 레코드가 있는 테이블 전체가 잠금되기도 한다. 따라서 우리가 예상하는 것보다 더 넓은 범위가 잠금되기도 한다. <br/><br/>

실시간 멀티플레이 온라인 게임에서 플레이어 정보는 자주 변경된다. 몬스터 하나를 잡을 때마다 변경되어야 할 테니까. 이러한 상황에서 트랜잭션은 심각한 문제를 일으킬 수 있다.
그러나 너무 걱정할 필요는 없다. 게임 서버는 플레이어 정보를 메모리에 보관하고, 플레이어의 데이터를 게임 서버 안에 있는 메모리에서 변경하며, 변경된 내용을 DB에 저장한다.
즉, DB를 세이브 데이터처럼 사용하는 셈이다. 게임 서버 안 메모리가 연산의 주요 대상이므로 두 플레이어 간 아이템 거래 같은 중요한 처리도 게임 서버 안 메모리에서 모두 판정이
끝난 후 뒤늦게 DB에 기록된다. 이 경우 앞서 본 트랜잭션 예처럼 DB에 변경을 가하다가 "뭔가 잘못되었으니 롤백하자" 라고 할 필요가 없다.
```c++
// 게임 서버 메모리와 DB에서 두 플레이어 간 아이템 교환
void RequestExchangeItems(Player1, Player2, item1, item2) {
  // 각 플레이어는 아이템을 맞게 갖고 있는가?
  if (player1.hasItem(item1) == false) {
    // 실패를 클라이언트에게 알리고 취소
    ResponseExchangeItemsFail(...);
    return;
  }
  if (player2.hasItem(item2) == false) {
    // 실패를 클라이언트에게 알리고 취소
    ResponseExchangeItemsFail(...);
    return;
  }

  // 서버 메모리에서 데이터 변경
  player1.removeItem(item1);
  player2.removeItem(item2);
  player1.addItem(item2);
  player2.addItem(item1);

  // DB에서 변경, DB에서는 제거 & 추가가 아니라 그냥 소유자만 변경
  // 게임 서버 메모리에서 이미 검증을 마쳤으므로 트랜잭션까지 할 필요는 없다.
  db.execute("update Item set owner={player2} where itemID={item1}");
  db.execute("update Item set owner={player1} where itemID={item2}");
}
```
그래서 게임 서버를 만들다 보면 DB 트랜잭션이 그렇게까지 필요하지는 않다. 

### 트랜잭션 고찰
#### 트랜잭션이 그렇게 까지 필요하진 않다.
게임 서버가 DB에 있는 레코드 2개 이상에 플레이어 데이터를 저장하다 어떤 오류가 발생해서 둘 중 하나를 저장하지 못 했다면 일관성이 깨질 것이다.
그러나 이러한 일은 자주 발생하지 않는다. DB의 트랜잭션 기능은 주로 논리적 실패(Money가 음수가 된 경우 등) 때문에 롤백할 때 사용하는 것이 대부분이다.
즉, "게임 서버 메모리에서 사전 검증을 다 해 버리는 특성" 덕분에 트랜잭션이 꼭 필요한 상황은 적다고 보면 된다.<br/><br/>

#### 그러나 가능성이 0은 아니다.
게임 서버에서 사전 검증을 마쳤다고 하더라도 중간에 크래시가 나는 위험성 등을 고려하지 않을 수 없다. 예를 들어 앞의 예시 코드 아래쪽에 있는 질의 구문을 실행하던 중 
두 번째 db.execute()를 하기 직전에 게임 서버에서 크래시가 나면 어떻게 될까? DB에 값이 잘못 저장된 상태가 될 것이다. 이러한 경우라면 트랜잭션이 필요해 보인다. <br/><br/>

#### 그래서 사용하자니 확실한 성능 저하가 발생한다.
그러나 트랜잭션으로 발생하는 성능 저하와 데드락 가능성을 완전히 없애고 싶을 수도 있다. 이렇게 레코드를 2개 이상 기록하되 전부 아니면 전무하게 기록하는 동시에
트랜잭션을 사용하기 어려운 상황이라면 어떻게 해야 할까? <br/><br/>

#### 여러 가지 추가 옵션을 생각할 수도 있다.
여러 가지 방법이 있다. 일단 어딘가에 로그를 남겨 두고 두 플레이어의 레코드를 업데이트 하는 것이다. 그리고 두 레코드의 업데이트가 완료되면 해당 로그를 지워 버리는 것이다.
또 다른 방법으로는 트랜잭션에서 잠금 수준을 완화하는 것이다. "다른 곳에서도 읽기 하는 것을 허락한다"라는 것으로 이렇게 하면 DB의 ACID 특징을 다소 위반하게 된다.
물론 그 대신 데드락이 매우 적거나 없어지는 효과를 볼 수 있으니 일장일단의 선택인 셈이다.

#### 결국은 한 쪽 입장을 선택해야 한다.
* 게임 서버가 플레이어 정보를 메모리에 항상 보관하고 있다.
* 플레이 처리의 주체는 게임 서버 내부의 메모리 안에서 이루어진다.
* DB는 세이브 데이터 역할 정도만 한다.

이러한 상황에서는 트랜잭션 사용으로 얻는 원자성 효과보다 교착 상태나 병렬성 하락으로 일어나는 손실이 더 크다고 한다. 이 글을 쓴 필자는
게임 서버에서 플레이어의 데이터는 메모리에서 주력으로 일어나고 DB는 콜드 데이터를 다루므로 DB에서 원자성을 위해 공을 들이는 것이 이득보다
손해가 조금 더 크다고 말하는 것.

<hr/><br/><br/>
$\it{\large{\color{#DD6565}외래키}}$









