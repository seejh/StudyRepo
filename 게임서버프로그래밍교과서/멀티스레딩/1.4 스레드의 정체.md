# 1.4 스레드의 정체
CPU가 하나만 있는 기기라고 가정해보자. CPU는 하나인데 어떻게 여러 프로그램이 동시에 실행될 수 있을까? <br/>

사람의 기준으로 생각했을 때 해야 하는 일 a, b가 있으면 a를 다하고 b를 가던가 a를 하다가 멈추고 b를 하다가 멈추고 a를 할 것이다. 여튼 동시에 두 가지 일을 할 수 없다는 것이다. <br/>

컴퓨터의 기준으로 생각했을 때 컴퓨터도 동시에 두 가지 일을 동시에 할 수 없다. 따라서 컴퓨터도 이 작업 저 작업 번갈아 가면서 하게 된다. 여러 프로세스와 여러 스레드를 동시에 실행해야 하는 운영체제는 이렇게 여러 프로세스와 각 프로세스 안에 있는 스레드들을 일정 시간마다 번갈아 가면서 실행한다. 각 스레드를 실행하다 말고 다른 스레드를 실행하는 과정을 컨텍스트 스위치(context switch)라고 한다.<br/>

그런데 이 컨텍스트 스위치는 컴퓨터 입장에서도 별것 아닌 일이 아니다. 컨텍스트 스위치를 하는 과정에서 적지 않은 양의 연산이 발생한다. 우선 실행 중이던 스레드의 상태(호출 스택 등)를 어딘가에 저장하고, 과거에 실행하다가 만 다른 스레드 중에서 하나를 고른다. 고른 스레드의 상태(호출 스택 등)를 복원하고 그런 다음 실행하던 지점으로 강제 이동한다.<br/>
<img width="437" height="225" alt="image" src="https://github.com/user-attachments/assets/c4a25c02-2e3b-428f-8529-eb61b0efef98" /><br/>
위의 그림에서 컨텍스트 스위치 횟수가 늘어 날수록 T1과 T2에 할당되는 시간은 줄어들 것이고 이는 비효율적이라고 할 수 있다. 컨텍스트 스위치를 많이 하면 성능이 안 좋다고 하니까 그렇다면 최대한 덜하면 되지 않을까? 하지만 이것도 문제가 될 수 있다. <br/>

앞서 언급했던 '로딩 중에 애니메이션을 뿌리는' 경우를 보자. 1초 당 한 번의 컨텍스트 스위치만 일어나게 한다면 애니메이션이 뚝뚝 끊겨서 보일 것이다. 그래서 컨텍스트 스위치는 기본적으로 '사람 입장에서 쾌적할 수 있는' 가급적 긴 시간 단위로 이루어진다. 이 시간 단위를 타임 슬라이스(time slice)라고 한다. 운영체제나 cpu 같은 환경에 따라 다르지만 보통 스레드 하나가 일시 정지했다 다시 시작하는 데까지 걸리는 시간은 약 5ms 이다. 사람 입장에서는 갑갑함을 느끼지 않을 만큼 짧은 시간이지만, 컴퓨터 입장에서는 초당 5억 개의 명령어를 처리할 수 있는 cpu라면 250만 개(5억 * 5/1000)의 명령어를 처리할 수 있는 시간이다.<br/>

## cpu 개수와 스레드 개수의 관계
스레드 개수가 cpu 개수보다 적다면 컨텍스트 스위치가 일어날 이유가 없다. 하지만 실제로는 외부적인 요인으로 인해 컨텍스트 스위치를 하게 되고 작업 관리자를 열어 보면 스레드가 수천 개나 있는데 이 경우 성능 문제는 없을까. 그러려면 스레드 생명 주기에 대해서 알아야 한다.

## 스레드 생명 주기(Thread Life Cycle)
스레드 생명 주기는 언어/플랫폼에 따라 표현이 조금씩 다르지만 공통적으로 잡히는 큰 흐름은 비슷하다.
### 1) New (생성 상태)
* 스레드가 생성되고 아직 실행 하지 않는 상태. 
* cpu 스케줄러의 대상이 되지 않음.
* c++의 경우 std::thread로 객체를 생성하면 즉시 os 스레드가 만들어져서 실행

### 2) Runnable (실행 가능 상태)
실제로 cpu를 점유한 건 아니고 ready queue에 들어가 스케줄러에 의해 cpu가 배치될 때까지 대기.

### 3) Running (실행 상태)
* cpu에서 실제로 스레드의 명령어가 수행 중.
* cpu 점유가 끝나면 다시 runnable로 내려간다.
* runnable <-> running 이 과정을 개발자가 직접적으로 컨트롤 할 수 없다.

### 4) Waiting / Blocked (대기 상태)
* 스레드가 특정 조건/자원을 기다리느라 cpu에 올라올 수 없는 상태.

스레드 코드 안에서 아래와 같은 동작을 수행할 때
* std::this_thread::sleep_for(), sleep_until() = Timed Waiting
* std::mutex에서 lock() 호출, 다른 스레드가 점유중인 경우 = Blocked
* I/O 요청 후 완료 대기 = Waiting

이와 같은 경우 스레드는 OS가 관리하는 wait queue로 이동하고 
조건이 충족되면 다시 Runnable로 돌아간다.

### 5) Terminated (종료 상태)
* 스레드 함수가 리턴하면 os 차원에서 스레드가 종료된다.
* 하지만 c++ 객체(std::thread)는 여전히 살아있고 joinable 상태.
  * t.join() : 메인 스레드가 종료된 스레드를 수거
  * t.detach() : 스레드를 백그라운드로 떼어내고 알아서 종료하게 둠
* 위의 두 가지를 하지 않고 std::thread 객체가 파괴된다면 std::terminate()가 호출된다.

## 컨텍스트 스위치가 언제 일어나는가
컴퓨터가 실행하는 명령어는 기본적으로 기계어 명령어 단위로 실행한다. 컨텍스트 스위치도 마찬가지이다. 다시 말해 기계어 명령어를 수행하다 말고 컨텍스트 스위칭을 하지 않는다. 한 기계어 명령어를 다 수행하고 나서 컨텍스트 스위치를 한다.<br/>

C++로 프로그래밍을 하는 경우, 한 구문은 기계 명령어 여러 개로 컴파일 되고 이 말은 우리 프로그램의 소스 코드 한 줄을 수행하는 도중에 컨텍스트 스위치가 발생할 수 있다는 것이다. 예를 들어 아래와 같은 C 구문이 있다.
```c++
a++;
```
이를 기계 명령어로 변경하면 아래와 같다.
```
// 여기서 r1, r2는 레지스터이고 a와 b는 메모리 공간
// 레지스터에 값 적재, 연산, 메모리에 저장
(1) ...
(2) r1 = a
(3) r2 = r1 + 1
(4) a = r2
(5) ...
```
한 줄의 C++ 구문이 여러 기계 명령어로 되어 있을 수 있고 위의 기계어 과정에서 컨텍스트 스위치가 일어나는 구간이 항상 일정하다면(예: 4번 과정에서 5번 과정으로 넘어가는 구간에서만 발생) 큰 문제는 되지 않지만 실제로는 어디서 일어날 지 알 수가 없고 이것이 문제가 된다. 

# 1.5 스레드 주의 사항
## 경쟁 상태(Race Condition), 데이터 레이스(Data Race)
스레드 2개가 값 하나에 동시에 접근하는 경우를 보자. 
```c++
int main() {
 // 
 int a = 0;
 int count = 10'0000;

 // 스레드 1
 thread t1([]() {
  for (int i = 0; i < count; i++) {
   a++;
  }
 });
 // 스레드 2
 thread t2([]() {
  for (int i = 0; i < count; i++) {
   a++;
  }
 })

 t1.join();
 t2.join();

 //
 cout << a << endl;
}
```
공용으로 접근하는 변수 a = 0에서 시작하고 스레드 1, 2가 각각 10만 번씩 연산해서 모든 스레드가 끝난 후 a값을 조회하면 20만이 나올 것 같지만 실제로는 20만 보다 훨씬 미달하는 값이 나온다. 왜 그렇게 될까?<br/>

위에서 우리는 a++와 같은 c++에서 하는 연산이 기계 명령어로는 여러 개로 이루어진다는 것을 알았다. 
```
r1 = a (1)
r2 = r1 + 1 (2)
a = r (3)
```
위에서 1~3번 구간 중 어디에서든 컨텍스트 스위치가 일어날 수 있다. 그로 인해 아래와 같은 상황이 나온다.
```
// 스레드 1
r1 = a(0)

// 스레드 2
r3 = a(0)
r4 = r3(0) + 1
a = 1 // 메모리 a의 값이 스레드 2에 의해서 1로 변경

// 스레드 1
r2 = r1(0) + 1 
a = 1 // 스레드 1에서 레지스터의 값으로 a를 변경
```
어느 스레드에서 작업하고 있는 값을 다른 스레드에서 변경을 하고 있고 이러한 문제 때문에 원하는 값이 도출되지 않는다.
이러한 경우를 경쟁 상태, 데이터 레이스라고 한다.

## 임계 영역(Critical Section)과 뮤텍스(Mutex)
경쟁 상태(Race Condition)를 해결하는 여러 방법 중 하나는 어떤 스레드에서 x에 액세스하는 동안 다른 스레드에서는 x에 액세스하지 못하게 하는 것이다. 이때 사용하는 것이 뮤텍스이다. 뮤텍스는 상호 배제(Mutual Exclusion)의 줄임말이며 사용하는 방법은 다음과 같다.
```
x를 보호하는 뮤텍스 mx를 만든다.
스레드는 x를 건드리기 전에 mx에 사용권을 요청한다.
스레드는 x에 액세스 한다.
액세스가 끝나면 mx에 사용권을 반환한다.

실제 코드로는 아래와 같다.
std::mutex mx; // (1) 뮤텍스 생성
mx.lock(); // (2) 뮤텍스 권한 획득
x = x + 1; // (3) 연산
mx.unlock(); // (4) 뮤텍스 권한 해제
```
(2) 번 과정에서 스레드1이 권한을 획득하려고 하는데 스레드2가 이미 선점했다면 스레드1은 스레드2가 작업을 완료하고 권한을 반환할 때까지 대기하게 된다. 그런데 위와 같이 매번 잠그고(lock) 풀고(unlock)하는 것을 호출하는 것은 번거로울 뿐만 아니라 예외 처리 코드도 작성하기 힘들게 한다. 위의 코드를 수행하다가 3번 구간에서 c++에서 예외를 던지면 뮤텍스를 해제하는 4번 과정은 실행되지 못하고 다른 스레드는 진입할 수 없게 된다. 이를 해결하려면 try-catch 구문으로 감싸서 예외가 발생하더라도 잠금 해제(unlock)를 할 수 있어야 한다. 벌써 귀찮다. 그래서 아래와 같이 하게 된다.
```c++
std::mutex m;
{
 // 블록 내에서 객체 lock 생성, 이 구간 벗어나면 소멸, lock_guard 소멸 시에 락 해제
 std::lock_guard<std::mutex> lock(m);
 cal(x);
}
```

## 교착 상태(데드락, Deadlock)
멀티스레드 프로그래밍에서 교착 상태란 두 스레드가 서로를 기다리는 상황을 의미한다.
```c++
int main() {
 mutex m1;
 mutex m2;

 thread t1( [&]() {
  m1.lock(); // m1 락 획득
  this_thread::sleep_for(chrono::seconds(3)); // 3초 대기
  m2.lock(); // m2 락 획득 시도
 });
 thread t2( [&]() {
  m2.lock();
  this_thread::sleep_for(chrono::seconds(3));
  m1.lock();
 });

 t1.join();
 t2.join();
}
```
위와 같은 경우에 데드락이 발생한다. t1이 m1을 획득한 상태에서 m2를 원하고 t2가 m2를 획득한 상태에서 m1을 원하고 있다. 서로가 원하는 락을 서로 가지고 있고 놔주지 않기에 더 이상 작업이 진전되지 않고 현 상황을 유지하게 된다. <br/>

게임 서버에서 교착 상태가 되면 발생하는 현상은 다음과 같다.
* cpu 사용량이 현저히 낮거나 0%
* 반응이 없음. 뭔가 요청을 보냈는데 응답을 안함.

교착 상태가 발생했을 때 디버거로 원인을 찾는 방법을 알아보자. 
```
// 코드
int main() {
 mutex m1;
 mutex m2;

 thread t1( [&]() {
  m1.lock();
  cout << "t1 locked m1" << endl;
  this_thread::sleep_for(chrono::seconds(3));
  m2.lock();
  cout << "t1 locked m2" << endl;
 });
 thread t2( [&]() {
  m2.lock();
  cout << "t2 locked m2" << endl;
  this_thread::sleep_for(chrono::seconds(3));
  m1.lock();
  cout << "t2 locked m1" << endl;
 });
}
```
위의 코드를 실행하면 교착 상태에 걸리게 되고 이때 디버거로 확인한다. 
```
교착 상태 발생 -> 디버그 일시 정지 -> 비주얼 스튜디오 상단 메뉴에서 디버그 -> 창 -> 스레드
```

스레드 호출 스택을 펼쳐서 각 스레드 번호와 스레드가 중단된 지점을 확인한다.<br/>
<img width="594" height="151" alt="image" src="https://github.com/user-attachments/assets/19990ada-252d-4453-a437-64c54cc1ac12" /><br/>

잠금을 하려고 하는데 다른 스레드가 락을 선점하고 있다는 내용이며 스레드 번호를 보면 각 스레드 번호를 가리키고 있다.<br/>
<img width="437" height="356" alt="image" src="https://github.com/user-attachments/assets/0cbc6031-bfc7-4606-89ae-a0975e1b1c4a" /><br/>

## 잠금 순서 규칙
위와 같이 여러 뮤텍스를 사용할 때 교착 상태(데드락)을 예방하는 방법이 있다. 잠금 순서를 정해주고 정해진 순서로만 잠금을 진행하는 것이다.<br/>

뮤텍스 A, B, C가 있고 A->B->C 순으로 잠근다고 할 때 코드는 아래와 같아야 한다.
```
lock(A) -> lock(B) -> lock(C) -> unlock(C) -> unlock(B) -> unlock(A)

// 또는 이런 경우들도 괜찮다.
// A->B
lock(A) -> lock(B) -> unlock(B) -> unlock(A)

// B->C
lock(B) -> lock(C) -> unlcok(C) -> unlock(B)

// 심지어 A->C도 안전하다.
lock(A) -> lock(C) -> unlock(C) -> unlock(A)
```
B->A, C->A와 같은 순서 역행만 아니면 된다.

### 재귀 뮤텍스가 있는 경우
#### 재귀 뮤텍스란?
재귀 뮤텍스란 한 스레드가 동일 뮤텍스에 대해서 여러번 잠그는 것이 가능한 뮤텍스로 우리가 사용하는 기본 뮤텍스(std::mutex)는 재귀가 불가능하다. 재귀가 가능하게 하려면 recursive mutex를 사용해야 한다.<br/>

재귀 뮤텍스 내부에 어떤 스레드가 잠금을 했고 몇 번을 잠금했는지가 체크되어 있다. 그래서 스레드1이 뮤텍스 M에 대해서 잠금을 한 번한 상태에서 잠금을 한 번 더 요청하면 재귀 뮤텍스는 잠금을 두 번한 것을 내부적으로 기록하고 unlock()을 두 번 해주어야 잠금이 해제된다. 
```
lock(M); // 스레드1이 한 번 잠금
lock(M); // 스레드1이 두 번 잠금
unlock(M); // 스레드1이 하나를 해제, 여전히 잠금 유지
unlock(M); // 잠금 해제
```

#### 재귀 뮤텍스를 사용할 때 잠금 순서
```
// A -> B -> C -> B -> A
lock(A) -> lock(B) -> lock(C) -> lock(B) -> lock(A)
-> unlock(C) -> unlock(B) -> unlock(A)

// 해석
위에서 "lock(C) -> lock(B) -> lock(A)" 구간은 잠근 순서 그래프와 거꾸로 가고 있는데 교착 상태일까? 아니다. 이미 잠근 것에 대한 재귀 잠근은 잠금 순서 그래프와 상관없다. "lock(A) -> lock(B) -> lock(C)" 구간은 첫 잠금이고 이때는 잠금 순서 그래프를 지켰다. 그 후에는 이미 잠근 것을 또 잠그는 것으로 잠금 순서 그래프를 무시해도 된다.

// 하지만 첫 잠금에서 순서를 어긴다면 교착 상태를 일으킨다.
// A -> C -> B -> C -> A
lock(A) -> lock(C) -> lock(B) -> lock(C) -> lock(A)
unlock(C) -> unlock(B) -> unlock(A)

// 해석
"lock(A) -> lock(C)" 까지는 괜찮으나 그 후에 lock(B)를 잡는것은 첫 잠금이고 B를 잡고 C를 잡아야 하는 잠금 순서를 어겼다. 따라서 교착 상태를 일으킨다. 그 후의 "-> lock(C) -> lock(A)"는 재귀 잠금으로 안전하다.
```

핵심은 다음과 같다. 데드락(교착 상태)이 발생하지 않으려면 잠금의 순서를 정해줘야 한다. 이 잠금의 순서를 유지하는 방법은 첫 잠금의 순서를 지켜야 한다.

## 병렬성과 시리얼 병목
뮤텍스가 보호하는 영역이 너무 넓으면 스레드가 여럿이라 하더라도 하나일 때와 별반 차이가 없다. 여러 CPU가 각 스레드의 연산을 실행하여 동시 처리량을 올리는 것을 병렬성(parallelism)이라 한다. 그런데 어떤 이유로 이러한 병렬성이 제대로 나오지 않는 것, 즉 병렬로 실행되게 프로그램을 만들었는데 일부만 연산을 수행하는 현상을 시리얼 병목(bottleneck)이라고 한다. <br/>

병목이 있을 때 cpu 개수가 많을수록 총 처리 효율성이 떨어지는 현상을 암달의 법칙(Amdahl's Law) 또는 암달의 저주라고 한다.



싱글스레드 게임 서버<br/>
멀티스레드 게임 서버<br/>

## 스레드 풀링
멀티스레드 모델의 게임 서버를 개발할 대 스레드는 몇 개 만들고, 각 스레드는 무엇을 위해 일을 하게 만들면 좋을까

* 어떤 서버의 주 역할이 CPU 연산만 하는 스레드라면(즉, 디바이스 타임이 없다면) 스레드풀의 스레드 개수는 서버의 CPU 개수와 동일하게 잡아도 충분하다.
* 서버에서 데이터베이스나 파일 등 다른 것에 액세스하면서 디바이스 타임이 발생할 때 스레드 개수는 CPU 개수보다 많아야 한다.

## 이벤트
동기화 개체로서 여러 스레드 간에 특정 사건이 발생했음을 알리거나, 특정 이벤트가 발생할 때까지 스레드를 대기시키는데 사용된다.
2가지 방법이 있다.
### condition_variable(조건 변수)
* c++ 11 이상 표준 라이브러리에서 제공함으로 플랫폼이 변경되어도 사용 가능
* 유저 모드에서 동작하므로 가볍고 빠름
* mutex와 같이 사용

```c++
// 간단 예제로 이해

```

win32 이벤트 객체는 커널 모드로 사용되는 객체로 유저 모드로 사용되는 condition_variable이 더 가볍기에 condition_variable을 사용하는 것이 더 좋다고 한다. 다만 condition_variable은 스레드를 깨우는 역할만 하므로 동기화를 걸어주는 mutex와 같이 사용해야 한다.

### Win32 API Event object(win32 이벤트 객체)
* Windows OS API에서 제공함으로 윈도우즈 전용
* 커널 모드 객체
* 단독 사용

```c++
// CreateEvent : 이벤트 객체를 생성한다.
// CloseHandle : 이벤트 객체를 파괴한다.
// WaitForSingleObject : 이벤트를 기다린다.
// SetEvent : 이벤트에 신호를 준다.

```

수동 모드(manual reset)와 자동 모드(auto reset) 2가지 방식이 있고 

## 세마포어
뮤텍스는 오로지 스레드 1개만 자원을 액세스할 수 있게 한다. 하지만 세마포어는 원하는 개수의 스레드가 자원을 액세스할 수 있게 한다. 

## 원자적 연산 (Atomic Operation)
원자적 연산이란 연산이 중간에 중단되지 않고 전부 성공하거나 혹은 전혀 수행되지 않는 특성을 가지는 연산으로 앞에서 배운 c++에서의 a++;이라는 구문이 기계 명령어로 한 구문이 아니며 그 구간내에서 어디서 컨텍스트 스위칭이 발생할 지 모르기에 문제가 될 수 있다고 했는데 원자적 연산은 모든 연산이 수행되는 것을 보장한다.<br/>

c++에서 atomic 객체를 만들어서 atomic 객체가 제공하는 함수를 사용하는 방식으로 사용하게 되며 아래와 같이 사용하게 된다.
```c++
int main() {
 // atomic 객체 생성
 atomic<int> var;

 // atomic 함수 사용 - 보호됨
 var.fetch_add(1);

 // atomic 객체에서 함수 사용 안하고 그냥 연산 - 보호 안됨
 var = 5;
}
```

원자적 연산이 제공하는 연산
* 원자값 증가, 감소(이하 전부 c++ 기준 함수, fetch_add, fetch_sub)
* 원자값 변경(exchange)
* 원자값 조건부 변경(compare_exchange_strong

## 멀티스레드 프로그래밍 유의점
### 읽기와 쓰기 모두에 잠금을 하지 않음
메모리에 값을 쓰고 있는데 다른 스레드가 그것을 읽으면 망가질 수 있다는 것은 인지하지만, 그냥 값을 읽고만 있으면 잠금을 하지 않더라도 안전하다는 막연한 생각 때문에 발생한다.

```c++
void func1() {
 // lock(mutex_a); 누락
 print(a);
}

void func2() {
 lock(mutex_a);
 a = a + 10;
}
```

### 잠금 순서
앞에서 살펴본 데로 잠금 순서를 지키면 되지만 프로그램 규모가 커지면 이 규칙을 준수하는 것이 생각보다 어렵다. 제일 좋은 것은 잠금 순서 규칙을 최대한 적게 유지하는 것이다.

### 잠금 범위
잠금 객체 범위가 너무 넓으면 컨텍스트 스위치가 발생할 때 운영체제가 해야 할 일이 매우 많아진다. 그리고 병렬성이 떨어지기에 멀티스레드 프로그래밍의 이유가 퇴색된다. <br/>

잠금 범위를 좁히면 컨텍스트 스위치의 확률이 떨어지기는 한다. 

### 디바이스 타임이 섞인 잠금 피하기
디바이스 타임이 있는 곳에 다른 스레드가 자주 접근하는 리소스에 대한 잠금을 하지 말아야 한다. 한 가지 예로 로그 출력이나 콘솔 출력이 있다. <br/>

우리에게 매우 익숙한 콘솔 출력 함수(printf, cout)는 사실 운영체제 안에서 꽤 무거운 일을 한다. 커맨드 라인 출력은 MS-DOS에서 제공하는 인터럽트나 BIOS 인터럽트의 형태로 이루어지고 통상적인 게임 로직 연산 처리보다 훨씬 많은 시간을 차지한다. 그 밖에도 디스크나 네트워크 I/O의 디바이스 타임이 있다. 동시 접속자는 많은데 게임 서버에서 CPU 사용량이 적게 나오는 경우, 이 때문에 문제가 난다고 보면 된다고 한다. 

### 잠금 전염성으로 발생한 실수
멀티스레딩을 할 때 동기화되는 구간을 최대한 줄이기 위해 잠금으로 보호되는 리소스 값을 스택영역으로 가져온 뒤에 동기화를 해제하고 쓰고는 한다. 잠금 영역의 내용을 로컬로 가져오더라도 잠금을 유지해야 하는 경우에 대한 얘기이다.

### 잠금된 뮤텍스 삭제
### 일관성 규칙 깨기









