# 1.4 스레드의 정체
CPU가 하나만 있는 기기라고 가정해보자. CPU는 하나인데 어떻게 여러 프로그램이 동시에 실행될 수 있을까? <br/>

사람의 기준으로 생각했을 때 해야 하는 일 a, b가 있으면 a를 다하고 b를 가던가 a를 하다가 멈추고 b를 하다가 멈추고 a를 할 것이다. 여튼 동시에 두 가지 일을 할 수 없다는 것이다. <br/>

컴퓨터의 기준으로 생각했을 때 컴퓨터도 동시에 두 가지 일을 동시에 할 수 없다. 따라서 컴퓨터도 이 작업 저 작업 번갈아 가면서 하게 된다. 여러 프로세스와 여러 스레드를 동시에 실행해야 하는 운영체제는 이렇게 여러 프로세스와 각 프로세스 안에 있는 스레드들을 일정 시간마다 번갈아 가면서 실행한다. 각 스레드를 실행하다 말고 다른 스레드를 실행하는 과정을 컨텍스트 스위치(context switch)라고 한다.<br/>

그런데 이 컨텍스트 스위치는 컴퓨터 입장에서도 별것 아닌 일이 아니다. 컨텍스트 스위치를 하는 과정에서 적지 않은 양의 연산이 발생한다. 우선 실행 중이던 스레드의 상태(호출 스택 등)를 어딘가에 저장하고, 과거에 실행하다가 만 다른 스레드 중에서 하나를 고른다. 고른 스레드의 상태(호출 스택 등)를 복원하고 그런 다음 실행하던 지점으로 강제 이동한다.<br/>
<img width="437" height="225" alt="image" src="https://github.com/user-attachments/assets/c4a25c02-2e3b-428f-8529-eb61b0efef98" /><br/>
위의 그림에서 컨텍스트 스위치 횟수가 늘어 날수록 T1과 T2에 할당되는 시간은 줄어들 것이고 이는 비효율적이라고 할 수 있다. 컨텍스트 스위치를 많이 하면 성능이 안 좋다고 하니까 그렇다면 최대한 덜하면 되지 않을까? 하지만 이것도 문제가 될 수 있다. <br/>

앞서 언급했던 '로딩 중에 애니메이션을 뿌리는' 경우를 보자. 1초 당 한 번의 컨텍스트 스위치만 일어나게 한다면 애니메이션이 뚝뚝 끊겨서 보일 것이다. 그래서 컨텍스트 스위치는 기본적으로 '사람 입장에서 쾌적할 수 있는' 가급적 긴 시간 단위로 이루어진다. 이 시간 단위를 타임 슬라이스(time slice)라고 한다. 운영체제나 cpu 같은 환경에 따라 다르지만 보통 스레드 하나가 일시 정지했다 다시 시작하는 데까지 걸리는 시간은 약 5ms 이다. 사람 입장에서는 갑갑함을 느끼지 않을 만큼 짧은 시간이지만, 컴퓨터 입장에서는 초당 5억 개의 명령어를 처리할 수 있는 cpu라면 250만 개(5억 * 5/1000)의 명령어를 처리할 수 있는 시간이다.<br/>

### cpu 개수와 스레드 개수의 관계
스레드 개수가 cpu 개수보다 적다면 컨텍스트 스위치가 일어날 이유가 없다. 하지만 실제로는 외부적인 요인으로 컨텍스트 스위치를 하게 된다(작업 관리자에서 보면 스레드가 최소 수천 개는 있음). 

### 컨텍스트 스위치가 일어나는 단위
컴퓨터가 실행하는 명령어는 기본적으로 기계어 명령어 단위로 실행한다. 컨텍스트 스위치도 마찬가지로 기계어 명령어 단위로 일어난다. 다시 말해서 기계어 명령어를 수행하다 말고 컨텍스트 스위칭을 하지 않는다. 한 기계어 명령어를 다 수행하고 나서 컨텍스트 스위치를 한다.<br/>

C++로 프로그래밍을 하는 경우, 한 구문은 실제로 기계어 명령어 여러 개로 컴파일 된다. 이 말은 우리 프로그램의 소스 코드 한 줄을 수행하다가 컨텍스트 스위치를 할 수 있다는 것이다. 예를 들어 다음과 같은 C언어 구문이 있다.
```c++
b = a * 2;
```
이때 이를 기계어로 실행하면 다음과 같이 작동한다.
```
// 여기서 r1, r2는 레지스터이고 a와 b는 메모리 공간
(1) ...
(2) r1 = a
(3) r2 = r1 * 2
(4) b = r2
(5) ...
```
위에서 컨텍스트 스위치를 수행하는 것이 4를 수행하고 난 뒤5를 실행하기 전에 수행된다면 이는 큰 문제가 되지 않는다. 하지만 실제로는
어디에서 컨텍스트 스위치를 일으킬지 예상할 수 없다. 

# 1.5 스레드 주의 사항

임계 영역과 뮤텍스<br/>
경쟁 상태를 해결하는 여러 방법 중 하나는 다음과 같다.<br/>

교착 상태 <br/>
교착 상태 혹은 데드락<br/>

잠금 순서의 규칙<br/>
여러 뮤텍스를 사용할 때 교착 상태를 예방<br/>

병렬성과 시리얼 병목<br/>
뮤텍스가 보호하는 영역이 너무 넓으면 스레드가 여럿이라 하더라도 하나일 때와 별반 차이가 없다. 여러 CPU가 각 스레드의 연산을 실행하여 동시 처리량을 올리는 것을 병렬성(parallelism)이라 한다. 그런데 어떤 이유로 이러한 병렬성이 제대로 나오지 않는 것, 즉 병렬로 실행되게 프로그램을 만들었는데 일부만 연산을 수행하는 현상을 시리얼 병목(bottleneck)이라고 한다. <br/>

싱글스레드 게임 서버<br/>
멀티스레드 게임 서버<br/>

스레드 풀링<br/>

이벤트<br/>

세마포어<br/>

원자 조작<br/>
원자 조작(atomic operation)은 뮤텍스나 임계 영역 잠금 없이도 여러 스레드가 안전하게 접근할 수 있는 것을 의미한다. 원자 조작은 하드웨어 기능이며, 대부분의 컴파일러는 원자 조작 기능을 쓸 수 있게 한다. 원자 조작은 32비트나 64비트의 변수 타입에 여러 스레드가 접근할 때 한 스레드씩만 처리됨을 보장한다. <br/>

멀티스레드 프로그래밍의 흔한 실수들<br/>









