# 1.4 스레드의 정체
CPU가 하나만 있는 기기라고 가정해보자. CPU는 하나인데 어떻게 여러 프로그램이 동시에 실행될 수 있을까? <br/>

사람의 기준으로 생각했을 때 해야 하는 일 a, b가 있으면 a를 다하고 b를 가던가 a를 하다가 멈추고 b를 하다가 멈추고 a를 할 것이다. 여튼 동시에 두 가지 일을 할 수 없다는 것이다. <br/>

컴퓨터의 기준으로 생각했을 때 컴퓨터도 동시에 두 가지 일을 동시에 할 수 없다. 따라서 컴퓨터도 이 작업 저 작업 번갈아 가면서 하게 된다. 여러 프로세스와 여러 스레드를 동시에 실행해야 하는 운영체제는 이렇게 여러 프로세스와 각 프로세스 안에 있는 스레드들을 일정 시간마다 번갈아 가면서 실행한다. 각 스레드를 실행하다 말고 다른 스레드를 실행하는 과정을 컨텍스트 스위치(context switch)라고 한다.<br/>

그런데 이 컨텍스트 스위치는 컴퓨터 입장에서도 별것 아닌 일이 아니다. 컨텍스트 스위치를 하는 과정에서 적지 않은 양의 연산이 발생한다. 우선 실행 중이던 스레드의 상태(호출 스택 등)를 어딘가에 저장하고, 과거에 실행하다가 만 다른 스레드 중에서 하나를 고른다. 고른 스레드의 상태(호출 스택 등)를 복원하고 그런 다음 실행하던 지점으로 강제 이동한다.<br/>
<img width="437" height="225" alt="image" src="https://github.com/user-attachments/assets/c4a25c02-2e3b-428f-8529-eb61b0efef98" /><br/>
위의 그림에서 컨텍스트 스위치 횟수가 늘어 날수록 T1과 T2에 할당되는 시간은 줄어들 것이고 이는 비효율적이라고 할 수 있다. 컨텍스트 스위치를 많이 하면 성능이 안 좋다고 하니까 그렇다면 최대한 덜하면 되지 않을까? 하지만 이것도 문제가 될 수 있다. <br/>

앞서 언급했던 '로딩 중에 애니메이션을 뿌리는' 경우를 보자. 1초 당 한 번의 컨텍스트 스위치만 일어나게 한다면 애니메이션이 뚝뚝 끊겨서 보일 것이다. 그래서 컨텍스트 스위치는 기본적으로 '사람 입장에서 쾌적할 수 있는' 가급적 긴 시간 단위로 이루어진다. 이 시간 단위를 타임 슬라이스(time slice)라고 한다. 운영체제나 cpu 같은 환경에 따라 다르지만 보통 스레드 하나가 일시 정지했다 다시 시작하는 데까지 걸리는 시간은 약 5ms 이다. 사람 입장에서는 갑갑함을 느끼지 않을 만큼 짧은 시간이지만, 컴퓨터 입장에서는 초당 5억 개의 명령어를 처리할 수 있는 cpu라면 250만 개(5억 * 5/1000)의 명령어를 처리할 수 있는 시간이다.<br/>

### 컨텍스트 스위치가 언제 일어나는가
컴퓨터가 실행하는 명령어는 기본적으로 기계어 명령어 단위로 실행한다. 컨텍스트 스위치도 마찬가지이다. 다시 말해 기계어 명령어를 수행하다 말고 컨텍스트 스위칭을 하지 않는다. 한 기계어 명령어를 다 수행하고 나서 컨텍스트 스위치를 한다.<br/>

C++로 프로그래밍을 하는 경우, 한 구문은 기계 명령어 여러 개로 컴파일 되고 이 말은 우리 프로그램의 소스 코드 한 줄을 수행하는 도중에 컨텍스트 스위치가 발생할 수 있다는 것이다. 예를 들어 아래와 같은 C 구문이 있다.
```c++
b = a * 2;
```
이를 기계 명령어로 변경하면 아래와 같다.
```
// 여기서 r1, r2는 레지스터이고 a와 b는 메모리 공간
(1) ...
(2) r1 = a
(3) r2 = r1 * 2
(4) b = r2
(5) ...
```
한 줄의 C++ 구문이 여러 기계 명령어로 되어 있을 수 있고 위의 기계어 과정에서 컨텍스트 스위치가 일어나는 구간이 항상 일정하다면(예: 4번 과정에서 5번 과정으로 넘어가는 구간에서만 발생) 큰 문제는 되지 않지만 실제로는 어디서 일어날 지 알 수가 없고 이것이 문제가 된다. 

### cpu 개수와 스레드 개수의 관계
스레드 개수가 cpu 개수보다 적다면 컨텍스트 스위치가 일어날 이유가 없다. 하지만 실제로는 외부적인 요인으로 인해 컨텍스트 스위치를 하게 되고 작업 관리자를 열어 보면 스레드가 수천 개나 있는데 이 경우 성능 문제는 없을까. 그러려면 스레드 생명 주기에 대해서 알아야 한다.

### 스레드 생명 주기(Thread Life Cycle)
스레드 생명 주기는 언어/플랫폼에 따라 표현이 조금씩 다르지만 공통적으로 잡히는 큰 흐름은 비슷하다.
#### 1) New (생성 상태)
* 스레드가 생성되고 아직 실행 하지 않는 상태. 
* cpu 스케줄러의 대상이 되지 않음.
* c++의 경우 std::thread로 객체를 생성하면 즉시 os 스레드가 만들어져서 실행

#### 2) Runnable (실행 가능 상태)
실제로 cpu를 점유한 건 아니고 ready queue에 들어가 스케줄러에 의해 cpu가 배치될 때까지 대기.

#### 3) Running (실행 상태)
* cpu에서 실제로 스레드의 명령어가 수행 중.
* cpu 점유가 끝나면 다시 runnable로 내려간다.
* runnable <-> running 이 과정을 개발자가 직접적으로 컨트롤 할 수 없다.

#### 4) Waiting / Blocked (대기 상태)
* 스레드가 특정 조건/자원을 기다리느라 cpu에 올라올 수 없는 상태.

스레드 코드 안에서 아래와 같은 동작을 수행할 때
* std::this_thread::sleep_for(), sleep_until() = Timed Waiting
* std::mutex에서 lock() 호출, 다른 스레드가 점유중인 경우 = Blocked
* I/O 요청 후 완료 대기 = Waiting

이와 같은 경우 스레드는 OS가 관리하는 wait queue로 이동하고 
조건이 충족되면 다시 Runnable로 돌아간다.

#### 5) Terminated (종료 상태)
* 스레드 함수가 리턴하면 os 차원에서 스레드가 종료된다.
* 하지만 c++ 객체(std::thread)는 여전히 살아있고 joinable 상태.
  * t.join() : 메인 스레드가 종료된 스레드를 수거
  * t.detach() : 스레드를 백그라운드로 떼어내고 알아서 종료하게 둠
* 위의 두 가지를 하지 않고 std::thread 객체가 파괴된다면 std::terminate()가 호출된다.

# 1.5 스레드 주의 사항

임계 영역과 뮤텍스<br/>
경쟁 상태를 해결하는 여러 방법 중 하나는 다음과 같다.<br/>

교착 상태 <br/>
교착 상태 혹은 데드락<br/>

잠금 순서의 규칙<br/>
여러 뮤텍스를 사용할 때 교착 상태를 예방<br/>

병렬성과 시리얼 병목<br/>
뮤텍스가 보호하는 영역이 너무 넓으면 스레드가 여럿이라 하더라도 하나일 때와 별반 차이가 없다. 여러 CPU가 각 스레드의 연산을 실행하여 동시 처리량을 올리는 것을 병렬성(parallelism)이라 한다. 그런데 어떤 이유로 이러한 병렬성이 제대로 나오지 않는 것, 즉 병렬로 실행되게 프로그램을 만들었는데 일부만 연산을 수행하는 현상을 시리얼 병목(bottleneck)이라고 한다. <br/>

싱글스레드 게임 서버<br/>
멀티스레드 게임 서버<br/>

스레드 풀링<br/>

이벤트<br/>

세마포어<br/>

원자 조작<br/>
원자 조작(atomic operation)은 뮤텍스나 임계 영역 잠금 없이도 여러 스레드가 안전하게 접근할 수 있는 것을 의미한다. 원자 조작은 하드웨어 기능이며, 대부분의 컴파일러는 원자 조작 기능을 쓸 수 있게 한다. 원자 조작은 32비트나 64비트의 변수 타입에 여러 스레드가 접근할 때 한 스레드씩만 처리됨을 보장한다. <br/>

멀티스레드 프로그래밍의 흔한 실수들<br/>









