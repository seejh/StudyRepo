# 스레드 생명 주기(Lifecycle)
"생성, 종료, 실행, 실행 대기, 일시 정지"와 같은 상태들이 있다. os와 언어(c++, java) 등에 따라서 조금씩 다르게 설명하지만 큰 맥락은 비슷하다.
여기서는 c++ 기준으로 설명한다. <br/>

## 상태 도식화
<img width="464" height="188" alt="image" src="https://github.com/user-attachments/assets/26c88224-8773-4ed7-9163-a0ac00e36360" /><br/>

## 스레드 상태
#### 생성 (New)
* std::thread()를 통해 스레드를 생성하고 c++에서는 스레드 객체를 생성하면 바로 실행된다.

#### 실행 대기 (Runnable)
* 스레드가 실행될 준비가 되었지만 아직 CPU 스케줄링이 되지 않아 실행 대기 상태에 있는 것.
* 운영체제의 ready queue에 들어가서 cpu를 할당받는 것을 대기.

#### 실행 (Running)
* cpu 할당받아 실제로 작업을 하는 상태.

#### 일시 정지 (Blocked/Waiting)
스레드가 I/O 대기, lock 대기 등으로 잠시 실행 불가능한 상태.
##### Waiting
* 정지(wait)시키고 신호(notify)를 줘서 깨우는 것.
* c++에서 이를 사용하려면 condition_variable을 사용한다.

##### Timed_Waiting
* 시간 기준으로 스레드를 일시 정지 시키는 것.
* sleep_for(얼마동안 sleep), sleep_until(언제까지 sleep)등이 있다.

##### Blocked
* 락을 잡으려는 순간 다른 스레드가 이미 보유중이라면.
* OS 내부적으로 WaitQueue(락 대기열)에 등록.
* 뮤텍스 소유자가 unlock을 하면 대기 중인 스레드 중 1가 ready queue로 이동하여 runnable이 됨.

#### 소멸 (Terminated)
* 스레드가 함수 끝까지 실행되거나 return을 만나서 종료.
* OS 스레드 객체는 죽었지만 std::thread 객체는 아직 살아 있음.
* join()이나 detach()를 통해 std::thread 객체를 정리해야 한다.(명시를 안하면 std::terminate()가 호출된다., c++ 표준)

##### join()
* 메인 스레드가 해당 스레드가 끝날 때까지 기다림.
* OS 리소스 정리됨.

##### detach()
* 스레드를 백그라운드로 실행, 더 이상 제어할 수 없음.
* OS가 알아서 종료 시 리소스를 해제.

## 추가 내용
### 운영체제에서 스레드 스케줄링과 동기화 객체 처리(Runnable <-> Blocked)
```c++
std::mutex m;

void f() {
  std::lock_guard<std::mutex> lock(m);
}
```
#### 1. 경합 발생 시 상태 전이
* A 스레드가 m.lock()을 성공적으로 획득 -> Running 상태.
* B 스레드가 같은 m.lock() 호출 -> A가 이미 락 소유 중 -> 커널은 B를 뮤텍스 대기 큐(wait queue)에 넣음 -> Blocked 상태
* C 스레드도 m.lock() 요청하면 -> B 뒤에 붙음 -> 역시 Blocked.

#### 2. 락 해제 시
A 스레드가 m.unlock()을 호출하면, 커널은 대기 큐에서 하나의 스레드만 꺼내서 ready queue로 이동 -> Runnable 상태 -> 스케줄러가 cpu 배정 -> Running 상태

#### 3. 여러 스레드가 경합 중일 때
* B, C, D가 다 뮤텍스 락을 대기?
* A가 unlock -> B가 Runnable
* B가 Running -> lock 소유
* B가 unlock -> C가 Runnable

#### 4. 추가 내용
뮤텍스 대기 큐에서 어떤 스레드를 깨우느냐는 운영체제 정책에 따라 다르다.

#### 5. 요약
* mutex 경합 시 -> 밀린 스레드는 Blocked.
* 소유자가 unlock하면 -> Blocked 중 하나만 Ready(Runnable).

