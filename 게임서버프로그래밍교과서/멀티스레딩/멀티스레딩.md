# 1.1 프로그램과 프로세스
우리가 흔히 말하는 프로그램(program)이란 컴퓨터에서 실행되는 명령어 모음이 들어 있는 데이터 덩어리를 의미한다.
크게 코드(code)와 데이터(data)로 구성되어 있다. <br/>

우리가 프로그램을 더블클릭하여 실행하면 프로그램 안에 들어 잇는 명령어가 한 줄씩 실행되면서 프로그램은 뭔가 활동하는 상태가 된다.
이를 프로세스(process)라고 한다. <br/>

<img width="603" height="222" alt="image" src="https://github.com/user-attachments/assets/4715196b-a37b-4746-aa88-87be0db39792" /><br/>
프로그램은 디스크에 있고 이를 실행하면 프로그램에 있는 코드와 데이터를 프로세스 메모리(RAM)로 로드한다. 프로세스 메모리에는 프로그램 코드와 데이터는 물론 힙(heap)과 스택(stack)도 공존한다. 스택에는 현재 실행중인 함수들의 호출 기록과 사용 중인 로컬 변수들이 들어 있다.<br/>

윈도우 운영체제에서는 실행된 프로그램을 작업 관리자로 확인할 수 있다.<br/>
<img width="442" height="338" alt="image" src="https://github.com/user-attachments/assets/ef2efca5-f8f3-470e-9689-40110e8c66ad" /><br/>
위를 보면 실행 중인 프로세스는 여러 개임을 알 수 있고 같은 프로그램을 여러 개 동시에 실행할 수 도 있다. 이렇게 프로세스가 여러 개
실행되고 있는 것을 멀티프로세싱(multi-processing)이라고 한다.<br/>

# 1.2 스레드(thread)
각 프로세스에는 독립된 메모리 공간이 있다. 기본적으로 서로 다른 프로세스는 상대방의 메모리 공간을 읽고 쓸 수 없다. <br/>

일반적으로 운영체제는 대부분 스레드라는 기능을 제공한다. 스레드 역시 프로세스처럼 명령어를 한 줄씩 실행하는 기본 단위이다.
스레드와 프로세스의 차이점은 다음과 같다.
* 스레드는 한 프로세스 안에 여러 개가 있다.
* 한 프로세스 안에 있는 스레드들은 해당 프로세스의 메모리 공간을 공유한다.
* 스레드마다 스택을 가진다. 이는 각 스레드에서 실행되는 함수의 로컬 변수들이 스레드마다 있다는 뜻이다.

### 프로세스와 스레드
<img width="319" height="265" alt="image" src="https://github.com/user-attachments/assets/a5243bd8-bb73-4c28-bfc6-f3dd4829266e" /><br/>

프로세스 안에 스레드가 하나로만 동작하는 모델을 싱글 스레드(single thread)라고 하고 스레드가 여러 개 있어 동시에 여러 처리가 한 번에 일어나는 모델을 멀티스레드(multi thread)라고 한다. 싱글 스레드에서 기본으로 존재하는 스레드를 메인 스레드(main thread)라고 하고 멀티스레드를 위해 스레드를 더 추가할 수 있다. <br/>

프로그램은 많은 서브루틴 혹은 함수로 구성되어 있다. 프로그램이 실행될 때 C언어에서는 void main() 함수가 실행되고, C#에서는 메인 클래스의 Main() 함수가 실행된다. 메인 함수를 시작점으로 많은 함수가 실행된다. 그리고 그 함수들은 또 다른 함수들을 실행한다. <br/>

함수는 실행이 끝나면 자기 자신을 호출했던 호출자(caller) 함수를 실행했던 지점으로 되돌아가야 한다. 그렇게 하려면 어디까지 실행되다가 말았는지를 기억하고 있어야 한다. 이 정보가 저장되어 있는 곳을 호출 스택(call stack)이라고 한다. <br/>

visual studio를 사용하고 있다면 디버거를 사용해서 호출 스택을 확인할 수 있다.
아래와 같이 간단한 프로그램을 하나 만든 후 func3()에 디버그 중단점(debug break point)을 찍고 디버깅을 해본다.<br/>
<img width="261" height="217" alt="image" src="https://github.com/user-attachments/assets/4137a176-aade-4665-b8b7-a5e88470e34b" /><br/>

그러면 프로그램이 실행되다 디버거에 의해 일시 정지하게 되고 이 상태에서 아래 호출 스택 항목을 보면 아래와 같이 나온다.<br/>
<img width="506" height="206" alt="image" src="https://github.com/user-attachments/assets/933113aa-05f8-47f1-8084-5a1ea71e25de" /><br/>
위와 같이 현재 실행되고 있는 지점을 확인할 수 있다. 또한 호출 스택 안에는 각 함수 안에 선언된 지역 변수도 같이 들어 있다.
각 스레드는 실행 지점이 서로 다를 수 밖에 없다. 스레드를 실행할 때는 그 스레드가 최초로 실행할 함수를 지정하는데, 이때 함수가 서로 다르기 때문이다. 만에 하나 같은 함수를 실행한다 하더라도 그 함수에 넘긴 인자나 메모리 상태 등이 다르므로 결국 다른 실행 지점을 가리킬 수 밖에 없다. 할 수 있는 모든 것을 동일하게 맞추더라도 다를 수 밖에 없다. 그 이유는 후에 설명한다. <br/>

따라서 각 스레드는 각자 호출 스택을 따로 가진다.<br/>
### 스레드, 호출 스택, 힙의 관계
<img width="329" height="314" alt="image" src="https://github.com/user-attachments/assets/1757173b-0095-419b-97de-c893b8153e29" /><br/>

스레드를 생성하려면 운영체제나 런타임 라이브러리에서 제공하는 스레드 생성용 함수를 호출한다. 스레드는 아래와 같은 형식으로 시작하고 작동한다.
```c++
void main() {
  // 1. 메인 스레드는 프로그램 시작부터 존재

  // 2. 스레드2 추가
  t1 = CreateThread(ThreadProc, 1);

  // 3. 메인 스레드 작업

  // 4. 메인 스레드 대기
  t1.join();

  // 5. 프로그램 종료
}

void ThreadProc(int) {
  // 6. 스레드 작업 내용

  // 7. 스레드 작업 종료
}
```
위의 과정을 메인 스레드와 추가 스레드 입장에서 설명한다. 메인 스레드는 프로그램이 시작되면 시작부터 존재하고 2번 과정에서 스레드를 추가하고 3번 과정을 하다가 작업이 끝나면 4번 과정에서 추가된 스레드의 작업이 끝나기를 기다리게 된다. 그러다 추가된 스레드의 작업도 끝나면 5번 과정으로 이동해 프로그램을 종료한다. <br/>

추가 스레드는 2번 과정에서 스레드가 추가되면 6번 과정으로 넘어가서 작업을 하게 되고 작업이 끝나면 7번 과정으로 이동해서 소멸한다.
혹여나 4번 과정이 누락된 상태에서 메인 스레드가 추가된 스레드보다 먼저 종료하게 된다면 해당 프로세스는 끝나지 않는 좀비 프로세스가 되므로 주의해야 한다.
<br/>

### 스레드의 생명 주기
<img width="500" height="234" alt="image" src="https://github.com/user-attachments/assets/e0f92108-2fb8-47cb-9b72-4747db1fd7ef" /><br/>

# 멀티스레드는 언제 사용해야하나?
"동시에 여러 가지 일을 한꺼번에 실행할 수 있으니까 무조건 써야하지 않나"라는 생각이 들겠지만 멀티스레딩은 페널티가 존재하고 심지어
같은 연산을 하더라도 멀티스레드로 할 경우 오히려 연산속도가 더 느려질 수도 있다. 그 뿐만 아니라 멀티스레드는 조금만 실수해도 심각한 오류를 일으키며 심지어 오류를 찾기 힘들 때도 많다. <br/>

위와 같은 단점들이 있기에 멀티스레드 프로그래밍을 하기 전에 "왜 써야하는가?"에 대한 답을 분명하게 할 수 있어야 한다. <br/>

### 멀티스레드를 써야하는 대표적인 상황은 다음과 같다.
* 오래 걸리는 일 하나와 빨리 끝나는 일 여럿을 같이 해야 할 때
* 어떤 긴 처리를 진행하는 동안 다른 짧은 일을 처리해야 할 때
* 기기에 있는 CPU를 모두 활용해야 할 때

#### 오래 걸리는 일 하나와 빨리 끝나는 일 여럿을 같이 해야 할 때
이것에 대한 예로 게임 프로그램에서 로딩(loading)을 할 때를 들 수 있다. <br/>

게임을 켜고 게임 스테이지 안에 들어가기 전, 게임 프로그램은 캐릭터와 배경을 구성하는 그래픽 리소스를 로딩하기 위해 많은 양의 데이터를 디스크에서 읽어 와야 한다. 이것을 읽어 오는 동안 화면이 멈추어 있으면 사용자는 지루해 한다. 그래서 지루함을 덜고자 로딩이 진행되는 동안 로딩이 얼마나 진행되었는지 그래프로 보여 주고는 한다. <br/>
<img width="511" height="218" alt="image" src="https://github.com/user-attachments/assets/66557871-950d-4170-8bf6-53c859d71a87" /><br/>
만약에 멀티스레딩을 하지 않는다면 이처럼 "로딩하는 동안 다른 뭔가를 하도록" 어떻게 구현해 주어야 할까?
아마도 다음 코드처럼 "하나 로딩하고 하나 렌더링하기"를 반복해야 할 것이다.<br/>
```c++
void LoadScene() {
  LoadModel();
  Render();
  LoadTexture();
  Render();
  ....
}
```
당연히 코드가 매우 지저분하며 로딩하는 파일의 크기가 크다면 큰 파일을 로딩하는 동안에는 일시적으로 프레임률이 뚝뚝 끊길 것이다. 그러면 큰 파일은 부분(chunk) 단위로 로딩하면서 렌더링을 하면 어떨까? 좀 낫기는 하겠지만, 그래도 프레임률은 균일하지 못할 것이다.<br/>

이때 멀티스레드를 사용하면 두 가지 문제를 모두 해결할 수 있다. 다음을 보자.
```c++
bool isStillLoading; // 전역 변수

void ThreadTask() {
  LoadScene();
  LoadModel();
  LoadTexture();
  ...

  isStillLoading = false;
}

int main() {
  isStillLoading = true;

  thread t1(ThreadTask);

  while (isStillLoading) {
    FrameMove();
    Render();
  }
}
```
메인에서는 게임 루프(렌더링)를 돈다. 스레드에서는 필요한 데이터를 계속해서 디스크에서 로드한다. 이렇게 처리하면 동시에 두 가지 일을 처리하기에 로딩이 진행되는 동안 제법 부드러운 애니메이션을 선사할 수 있다. 

#### 어떤 긴 처리를 진행하는 동안 다른 짧은 일을 처리해야 할 때
게임 서버에서 볼 수 있는 이와 같은 케이스로는 플레이어 정보를 읽거나 쓰려고 디스크에 액세스하는 경우이다. 쉽게 말하면 db에 액세스하는 경우에 대한 얘기로 db에 액세스하는 스레드는 db에 작업을 요청하고 결과를 받기 위해서 대기하게 되는데 이 시간 동안 CPU는 놀게 된다. 이 노는 시간을 다른 작업에 분배하면 서버의 실행 성능을 개선할 수 있다. <br/>

플레이어 정보를 디스크에 기록하는 시간은 1만분의 1초(0.1ms) 정도이다. 매우 짧은 시간이지만 상용 게임 서버 입장에서는 엄청난 시간 낭비이다. <br/>

디스크는 모터로 구성된 기계 장치이다. 따라서 전자 회로보다 일을 훨씬 느리게 한다. 물론 최근에는 SSD 디스크를 많이 사용하지만 SSD라고 해도 하드디스크보다 상대적으로 빠를 뿐 RAM이나 CPU 안의 캐시 메모리와 비교했을 때 훨씬 느리다.<br/>

디스크에 플레이어 정보를 액세스하는데 1만 분의 1초가 걸린다는 것은 해당 행위를 1초에 만 번 이상은 할 수 없다는 것이다. FPS 게임은 클라이언트 하나에 초당 30번의 요청을 처리해야 한다. 이러한 클라이언트가 서버 기기에 1만 개 접속한다고 생각해보자. 이 서버는 초당 30 * 1만 = 30만 번의 처리를 해야 한다. <br/>

서비스를 오픈한 직후 플레이어들이 순식간에 우르르 게임에 접속한다면 어떻게 될까? 즉, 1만 분의 1초가 걸리는 일이 엄청나게 몰리는 상황이다. 최악의 경우 30만 번을 처리해야 할 서버가 초당 1만 번 밖에 처리하지 못하는 상황까지 이른다. <br/>

따라서 1만분의 1초라는 매우 긴 시간을 효율적으로 활용하려면 멀티스레딩을 하던지 비동기 프로그래밍을 해야 한다.

#### 기기에 있는 CPU를 모두 활용해야 할 때
2000년 중반까지는 CPU의 실행 속도, 즉 클록 수가 계속 증가했다. 하지만 그 이후부터는 클럭 수의 증가보다 CPU 코어(core) 개수 위주로 증가하고 있다. <br/>

이는 프로그램 개발자 측면에서 즐거운 일이 아니다. 기본적으로 스레드는 코어를 하나만 사용한다. 다시 말해 싱글스레드 프로그램은 컴퓨터의 CPU 코어 개수와 상관없이 1개만 쓴다. 나의 서버가 8코어 CPU를 장착했는데 싱글스레드로 게임 서버를 만든다면 서버는 전체 연산 성능의 1/8만 사용할 것이다. <br/>

실제로 체크해보자. 
```c++

// 소수 체크
bool IsPrimeNumber(int number) {
  if (number == 1)
    return false;
  if (number == 2 || nubmer == 3)
    return true;
  for (int i = 2; i < number - 1; i++) {
    if ((number % i) == 0)
      return false;
  }

  return true;
}

int main() {
  //
  vector<int> primes;

  // 시작 시간
  auto start = chrono::system_clock::now();

  // 연산
  for (int i = 1; i <= MaxCount; i++) {
    if (IsPrimeNumber(i))
      primes.push_back(i);
  }

  // 끝 시간 체크 및 시간 간격 확인
  auto end = chrono::system_clock::now();
  auto duration = chrono::duration_cast<chrono::milliseconds>(end - start).count();
  cout << "Took " << duration << " ms" << endl;

  // 소수 출력
  PrintNumbers(primes);
}
```




