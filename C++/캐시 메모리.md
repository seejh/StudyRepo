# 캐시 메모리(Cache Memory)
### 메모리 계층 구조 그림
레지스터 -> 캐시 -> 메인 메모리 순으로 속도 빠르고 CPU에 가깝고 비싸고 용량이 적다.<br/>
<img width="670" height="368" alt="image" src="https://github.com/user-attachments/assets/3eceec31-287d-4425-b585-1f27103c8a74" /><br/>

### 캐시
속도 차이가 나는 장치들간에 발생하는 병목 현상 해결을 위해 느린 장치로 가는 횟수를 줄이기 위해 중간에 더 빠른 장치에
데이터를 미리 가지고 있는 것. 어느 정도의 예측이 필요하기에 이를 위해 데이터 지역성이라는 것을 활용한다.<br/>

캐시 메모리는 L1, L2, L3 캐시로 나눌 수 있는데 level에 따라 숫자가 작을 수록 CPU와 가깝고 크기가 작다.
캐시에 많은 데이터를 담아 CPU 처리 속도를 올리는 것은 좋지만, 용량이 정해져있기 때문에 최대한 캐시 적중률(Cache Hit)을 높여 성능을 향상시켜야 한다.

#### Cache Hit
CPU가 참조하려는 데이터가 캐시 메모리에 있는 경우
#### Cache Miss
CPU가 참조하려는 데이터가 캐시 메모리에 없음

1) Compulsory Miss
한국말로 강제 미스. 데이터에 처음 접근시 캐시에 데이터를 올리기 위해 발생하는 캐시 미스.

2) Capacity Miss
캐시 용량이 부족하여 발생하는 미스. 프로그램 수행 시 접근하는 데이터의 양이 캐시의 사이즈를 넘어갈 경우 발생.
예를 들어 32k 캐시 용량을 가지고 있는데 128k 배열 데이터에 접근하는 경우 모두 저장할 수 없으므로 용량 부족에 의한 캐시
미스가 발생한다.

3) Conflict Miss

4) Coherence Miss


## 데이터 지역성(Data Locality)
대부분 프로그램은 한 번 사용한 데이터를 재사용할 가능성이 높고, 그 주변의 데이터도 곧 사용할 가능성이 높은 데이터 지역성을
가지고 있다. 데이터 지역성을 활용하여 메인 메모리에 있는 데이터를 캐시 메모리에 불러와 두고 프로세서가 필요한 데이터를 캐시 메모리에서 먼저 찾으면 시스템 성능을 향상시킬 수 있다.<br/>

### 시간지역성
최근에 참조된 데이터가 곧 다시 참조되는 특성
### 공간지역성
최근에 참조된 데이터와 인접한 데이터가 참조될 가능성이 높은 특성

## 캐시 배치 정책(=캐시 라인)
캐시 사상(mapping) 구조.

### Direct Mapped Cache (직접 사상)
<img width="482" height="338" alt="image" src="https://github.com/user-attachments/assets/d92e4fe6-cd07-46c7-a927-d4a44873cf5f" /><br/>
캐시메모리의 공간이 8개(000 ~ 111)이고 메인메모리의 공간이 32개(00000 ~ 11111)이라고 하면 
메인메모리의 주소가 00000, 01000, 10000, 11000인 곳의 데이터를 캐시 메모리의 주소가 000인 곳에서만 읽고 쓰는 방식이다.<br/>

이때 000을 인덱스 필드(Index Field), 인덱스를 제외한 나머지 비트 00, 01, 10, 11을 태그 필드(Tag Field)라 하고 기본적으로
태그 비트와 인덱스 비트 뒤에 데이터를 <br/>

간단하고 빠르지만 약점(conflict miss)이 크다. 캐시 메모리 공간 활용도가 굉장히 떨어지고 현대 CPU에서는 어지간하면
채택되지 않는 편이다.

### Fully Associative Cache(완전 연관 사상)
비어있는 메모리에 대해 크게 조건 없이 저장하여 캐시 메모리 공간 활용도가 높지만 찾는 것이 힘들다.
어떤 조건이나 규칙 없이 저장했으니 모든 캐시 블록에서 검색하게 된다.

### Set Associative Cache(집합 연관 사상)
direct와 fully의 장점을 섞었다고 할 수 있는 가장 나중에 나온 방식으로 현대 CPU 모든 계층의 캐시 메모리에서 
채택되는 방식.

특정 행을 지정해서 그 행 안의 어떤 열이든 비어있으면 저장하는 방식.
direct에 비해 검색은 오래 걸리지만 저장이 빠르고, fully에 비해 저장이 느린 대신 검색이 빠른 중간적인 특징을 가진다.


참조: <br/>
https://lolki.tistory.com/2 <br/>

